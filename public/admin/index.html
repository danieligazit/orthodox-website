<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Content Manager</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: #f5f5f5;
      padding: 20px;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      padding: 30px;
    }
    
    h1 {
      margin-bottom: 30px;
      color: #333;
    }
    
    .auth-section {
      text-align: center;
      padding: 40px;
    }
    
    /* Tabs */
    .tabs {
      display: flex;
      gap: 10px;
      border-bottom: 2px solid #e0e0e0;
      margin-bottom: 30px;
    }
    
    .tab {
      padding: 12px 24px;
      background: none;
      border: none;
      border-bottom: 3px solid transparent;
      cursor: pointer;
      font-size: 16px;
      font-weight: 500;
      color: #666;
      transition: all 0.2s;
    }
    
    .tab:hover {
      color: #333;
    }
    
    .tab.active {
      color: #24292e;
      border-bottom-color: #24292e;
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    .btn {
      background: #24292e;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 500;
      transition: background 0.2s;
    }
    
    .btn:hover {
      background: #2f363d;
    }
    
    .btn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    
    .btn-success {
      background: #28a745;
    }
    
    .btn-success:hover {
      background: #218838;
    }
    
    .btn-primary {
      background: #007bff;
    }
    
    .btn-primary:hover {
      background: #0056b3;
    }
    
    .status {
      padding: 12px;
      border-radius: 6px;
      margin: 20px 0;
    }
    
    .status.success {
      background: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }
    
    .status.error {
      background: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }
    
    .status.info {
      background: #d1ecf1;
      color: #0c5460;
      border: 1px solid #bee5eb;
    }
    
    /* Toast Notification System */
    .toast-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 10000;
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-width: 400px;
    }
    
    .toast {
      background: white;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      padding: 16px 20px;
      display: flex;
      align-items: flex-start;
      gap: 12px;
      animation: slideIn 0.3s ease-out;
      min-width: 300px;
      max-width: 400px;
    }
    
    .toast.success {
      border-left: 4px solid #28a745;
    }
    
    .toast.error {
      border-left: 4px solid #dc3545;
    }
    
    .toast.info {
      border-left: 4px solid #17a2b8;
    }
    
    .toast.warning {
      border-left: 4px solid #ffc107;
    }
    
    .toast-icon {
      font-size: 20px;
      flex-shrink: 0;
      margin-top: 2px;
    }
    
    .toast.success .toast-icon {
      color: #28a745;
    }
    
    .toast.error .toast-icon {
      color: #dc3545;
    }
    
    .toast.info .toast-icon {
      color: #17a2b8;
    }
    
    .toast.warning .toast-icon {
      color: #ffc107;
    }
    
    .toast-content {
      flex: 1;
    }
    
    .toast-title {
      font-weight: 600;
      margin-bottom: 4px;
      color: #333;
    }
    
    .toast-message {
      font-size: 14px;
      color: #666;
      line-height: 1.4;
    }
    
    .toast-close {
      background: none;
      border: none;
      font-size: 20px;
      color: #999;
      cursor: pointer;
      padding: 0;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }
    
    .toast-close:hover {
      color: #333;
    }
    
    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    
    @keyframes fadeOut {
      from {
        opacity: 1;
        transform: translateX(0);
      }
      to {
        opacity: 0;
        transform: translateX(100%);
      }
    }
    
    .toast.dismissing {
      animation: fadeOut 0.3s ease-out forwards;
    }
    
    .deployment-status {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid #e0e0e0;
      font-size: 12px;
      color: #666;
    }
    
    .deployment-status.active {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .deployment-spinner {
      width: 12px;
      height: 12px;
      border: 2px solid #e0e0e0;
      border-top-color: #17a2b8;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .deployment-status-link {
      color: #17a2b8;
      text-decoration: none;
    }
    
    .deployment-status-link:hover {
      text-decoration: underline;
    }
    
    .items-list {
      margin-top: 30px;
    }
    
    .item-item {
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 20px;
      margin-bottom: 20px;
      background: #fafafa;
      position: relative;
    }
    
    .item-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    
    .item-header h3 {
      margin: 0;
      color: #333;
    }
    
    .item-controls {
      display: flex;
      gap: 5px;
    }
    
    .item-controls button {
      padding: 6px 12px;
      font-size: 14px;
    }
    
    .item-item .meta {
      color: #666;
      font-size: 14px;
      margin-bottom: 15px;
    }
    
    .form-group {
      margin-bottom: 15px;
    }
    
    .form-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
      color: #333;
    }
    
    .form-group input,
    .form-group textarea {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      font-family: inherit;
    }
    
    .form-group textarea {
      min-height: 100px;
      resize: vertical;
    }
    
    .form-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
    }
    
    .list-item {
      background: white;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 10px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .list-item input {
      flex: 1;
      border: none;
      padding: 5px;
    }
    
    .btn-small {
      padding: 6px 12px;
      font-size: 14px;
    }
    
    .btn-danger {
      background: #dc3545;
    }
    
    .btn-danger:hover {
      background: #c82333;
    }
    
    .hidden {
      display: none;
    }
    
    .page-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    
    .user-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 1px solid #e0e0e0;
    }
    
    .user-info {
      display: flex;
      align-items: center;
      gap: 10px;
      color: #666;
      font-size: 14px;
    }
    
    .btn-outline {
      background: white;
      color: #24292e;
      border: 1px solid #24292e;
    }
    
    .btn-outline:hover {
      background: #f5f5f5;
    }
    
    .sort-controls {
      display: flex;
      align-items: center;
      gap: 15px;
      margin-bottom: 20px;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 6px;
      border: 1px solid #e0e0e0;
    }
    
    .sort-controls label {
      font-weight: 500;
      color: #333;
      margin: 0;
    }
    
    .sort-controls select {
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      font-family: inherit;
      background: white;
      cursor: pointer;
    }
    
    .sort-controls select:focus {
      outline: none;
      border-color: #24292e;
    }
    
    .sort-warning {
      background: #fff3cd;
      color: #856404;
      border: 1px solid #ffc107;
      border-radius: 6px;
      padding: 12px 16px;
      margin-bottom: 20px;
      display: none;
    }
    
    .sort-warning.show {
      display: block;
    }
    
    .sort-warning-icon {
      font-weight: bold;
      margin-right: 8px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Content Manager</h1>
    
    <div id="auth-section" class="auth-section">
      <p>Please authenticate with GitHub to manage content.</p>
      <button id="login-btn" class="btn">Login with GitHub</button>
    </div>
    
    <div id="content-section" class="hidden">
      <div id="status"></div>
      <div id="toast-container" class="toast-container"></div>
      
      <div class="user-header">
        <div class="user-info">
          <span>Logged in as: <strong id="user-name">-</strong></span>
        </div>
        <button id="logout-btn" class="btn btn-outline">Logout</button>
      </div>
      
      <div class="tabs">
        <button class="tab active" data-tab="albums">Albums</button>
        <button class="tab" data-tab="about">About</button>
        <button class="tab" data-tab="press">Press Items</button>
      </div>
      
      <!-- Albums Tab -->
      <div id="albums-tab" class="tab-content active">
        <div class="page-header">
          <h2>Albums</h2>
          <button id="create-album-btn" class="btn btn-primary">Create New Album</button>
        </div>
        <div class="sort-controls">
          <label for="sort-field">Sort by:</label>
          <select id="sort-field">
            <option value="id">ID</option>
            <option value="releaseDate">Release Date</option>
            <option value="artist">Artist Name</option>
            <option value="title">Title</option>
          </select>
          <label for="sort-order">Order:</label>
          <select id="sort-order">
            <option value="asc">Ascending</option>
            <option value="desc">Descending</option>
          </select>
          <button id="apply-sort-btn" class="btn">Apply Sort</button>
        </div>
        <div id="sort-warning" class="sort-warning">
          <span class="sort-warning-icon">⚠</span>
          <strong>Warning:</strong> Applying a sort will permanently change the order of albums. The current manual ordering will be lost. Make sure to save your changes after sorting.
        </div>
        <div id="albums-list" class="items-list"></div>
      </div>
      
      <!-- About Tab -->
      <div id="about-tab" class="tab-content">
        <div class="page-header">
          <h2>About Page</h2>
        </div>
        <div id="about-content" class="form-container">
          <div class="form-group">
            <label>Paragraphs</label>
            <div id="about-paragraphs"></div>
            <button type="button" class="btn btn-small" onclick="addAboutParagraph()">Add Paragraph</button>
          </div>
        </div>
      </div>
      
      <!-- Press Items Tab -->
      <div id="press-tab" class="tab-content">
        <div class="page-header">
          <h2>Press Items</h2>
          <button id="create-press-btn" class="btn btn-primary">Create New Press Item</button>
        </div>
        <div id="press-list" class="items-list"></div>
        <p style="color: #666; padding: 20px;">Press items functionality coming soon. This is a placeholder.</p>
      </div>
      
      <button id="save-btn" class="btn btn-success" style="margin-top: 20px;">Save All Changes</button>
    </div>
  </div>

  <script>
    const PROXY_URL = 'https://decap-oauth-proxy.danieligazit.workers.dev';
    const REPO_OWNER = 'danieligazit';
    const REPO_NAME = 'orthodox-website';
    const ALBUMS_FILE_PATH = 'src/data/albums.json';
    const ABOUT_FILE_PATH = 'src/data/about.json';
    const BRANCH = 'main';
    const BASE_URL = 'https://danieligazit.github.io/orthodox-website';
    
    let token = localStorage.getItem('github-token');
    let albumsData = null;
    let aboutData = null;
    let pressData = { items: [] }; // Placeholder for press items
    
    // Tab switching
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        const tabName = tab.dataset.tab;
        
        // Update tabs
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        
        // Update content
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        document.getElementById(`${tabName}-tab`).classList.add('active');
      });
    });
    
    // Check for OAuth callback
    const urlParams = new URLSearchParams(window.location.search);
    const accessToken = urlParams.get('access_token');
    
    const storedToken = localStorage.getItem('github-token');
    
    if (accessToken) {
      // Only auto-login if we don't have a stored token (fresh login)
      if (!storedToken) {
        token = accessToken;
        localStorage.setItem('github-token', token);
        window.history.replaceState({}, document.title, window.location.pathname);
        // Get user info and load content
        fetch(`${PROXY_URL}/user`, {
          headers: { 'Authorization': `token ${token}` }
        })
        .then(response => {
          if (response.ok) {
            return response.json().then(user => {
              document.getElementById('user-name').textContent = user.login;
              loadContent();
            });
          }
          loadContent();
        })
        .catch(() => loadContent());
      } else {
        // Clear URL params if we already have a token (prevent re-login)
        window.history.replaceState({}, document.title, window.location.pathname);
      }
    } else if (token) {
      verifyToken();
    }
    
    document.getElementById('login-btn').addEventListener('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      
      // Add timestamp and random state to prevent caching and ensure fresh OAuth flow
      const timestamp = Date.now();
      const randomState = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
      
      // Disable button to prevent double-clicks
      const btn = document.getElementById('login-btn');
      btn.disabled = true;
      btn.textContent = 'Redirecting...';
      
      window.location.href = `${PROXY_URL}/auth?t=${timestamp}&state=${randomState}&force=true`;
    });
    
    document.getElementById('create-album-btn').addEventListener('click', createNewAlbum);
    document.getElementById('create-press-btn').addEventListener('click', () => {
      showStatus('Press items functionality coming soon!', 'info');
    });
    
    document.getElementById('apply-sort-btn').addEventListener('click', applySort);
    
    document.getElementById('logout-btn').addEventListener('click', () => {
      if (confirm('Clear admin session? You will need to login again to access the admin.')) {
        // Clear all state
        localStorage.removeItem('github-token');
        token = null;
        albumsData = null;
        pressData = { items: [] };
        
        // Clear any status messages
        const statusDiv = document.getElementById('status');
        statusDiv.classList.add('hidden');
        statusDiv.textContent = '';
        
        // Hide content and show auth
        document.getElementById('auth-section').classList.remove('hidden');
        document.getElementById('content-section').classList.add('hidden');
        document.getElementById('user-name').textContent = '-';
        
        // Clear URL parameters
        window.history.replaceState({}, document.title, window.location.pathname);
        
        showStatus('Session cleared. Please login again.', 'success');
      }
    });
    
    let hasWritePermission = false;
    let currentUsername = null;
    
    async function checkPermissions(username) {
      try {
        // Repository owner always has write permission
        if (username === REPO_OWNER) {
          hasWritePermission = true;
          return true;
        }
        
        // Check if user has write/admin permission to the repository
        const permResponse = await fetch(`https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/collaborators/${username}/permission`, {
          headers: {
            'Authorization': `token ${token}`,
            'Accept': 'application/vnd.github.v3+json'
          }
        });
        
        if (permResponse.ok) {
          const permData = await permResponse.json();
          // User has write or admin permission
          hasWritePermission = permData.permission === 'write' || permData.permission === 'admin';
          return hasWritePermission;
        } else if (permResponse.status === 404) {
          // User is not a collaborator
          hasWritePermission = false;
          return false;
        } else {
          // Other error - assume no permission to be safe
          hasWritePermission = false;
          return false;
        }
      } catch (error) {
        console.error('Error checking permissions:', error);
        // If we can't check, assume no permission to be safe
        hasWritePermission = false;
        return false;
      }
    }
    
    async function verifyToken() {
      try {
        const response = await fetch(`${PROXY_URL}/user`, {
          headers: { 'Authorization': `token ${token}` }
        });
        
        if (response.ok) {
          const user = await response.json();
          currentUsername = user.login;
          document.getElementById('user-name').textContent = user.login;
          
          // Check permissions
          const hasPermission = await checkPermissions(user.login);
          
          if (hasPermission) {
            showStatus(`Logged in as ${user.login}`, 'success');
            // Show edit controls
            document.getElementById('save-btn').style.display = 'block';
            document.getElementById('create-album-btn').style.display = 'block';
            loadContent();
          } else {
            // User doesn't have write permission
            document.getElementById('auth-section').classList.add('hidden');
            document.getElementById('content-section').classList.remove('hidden');
            
            // Hide edit controls
            document.getElementById('save-btn').style.display = 'none';
            document.getElementById('create-album-btn').style.display = 'none';
            
            document.getElementById('albums-list').innerHTML = `
              <div style="padding: 40px; text-align: center; color: #721c24; background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 4px; margin: 20px;">
                <h2 style="margin-top: 0;">Access Denied</h2>
                <p>You are logged in as <strong>${user.login}</strong>, but you do not have write permissions to this repository.</p>
                <p>Only collaborators with write or admin access can view and edit content.</p>
                <p style="margin-top: 20px; font-size: 14px; color: #856404;">
                  If you believe you should have access, please contact the repository owner to add you as a collaborator.
                </p>
              </div>
            `;
            showStatus('You do not have permission to access this admin panel.', 'error');
          }
      } else {
          // Token is invalid or expired
          throw new Error('Token invalid');
        }
      } catch (error) {
        // Clear invalid token and show login screen
        localStorage.removeItem('github-token');
        token = null;
        document.getElementById('auth-section').classList.remove('hidden');
        document.getElementById('content-section').classList.add('hidden');
        document.getElementById('user-name').textContent = '-';
        showStatus('Session expired or invalid. Please login again.', 'error');
      }
    }
    
    async function loadContent() {
      // Only load content if user has write permission
      if (!hasWritePermission) {
        return;
      }
      
      document.getElementById('auth-section').classList.add('hidden');
      document.getElementById('content-section').classList.remove('hidden');
      
      try {
        showStatus('Loading content...', 'info');
        
        // Load albums
        const albumsResponse = await fetch(`https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${ALBUMS_FILE_PATH}`, {
          headers: {
            'Authorization': `token ${token}`,
            'Accept': 'application/vnd.github.v3+json'
          }
        });
        
        if (!albumsResponse.ok) {
          const errorData = await albumsResponse.json().catch(() => ({}));
          throw new Error(errorData.message || `Failed to fetch albums: ${albumsResponse.status} ${albumsResponse.statusText}`);
        }
        
        const albumsFile = await albumsResponse.json();
        const albumsBinaryString = atob(albumsFile.content);
        const albumsBytes = new Uint8Array(albumsBinaryString.length);
        for (let i = 0; i < albumsBinaryString.length; i++) {
          albumsBytes[i] = albumsBinaryString.charCodeAt(i);
        }
        const albumsContent = new TextDecoder('utf-8').decode(albumsBytes);
        albumsData = JSON.parse(albumsContent);
        
        // Load about page
        try {
          const aboutResponse = await fetch(`https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${ABOUT_FILE_PATH}`, {
            headers: {
              'Authorization': `token ${token}`,
              'Accept': 'application/vnd.github.v3+json'
            }
          });
          
          if (aboutResponse.ok) {
            const aboutFile = await aboutResponse.json();
            const aboutBinaryString = atob(aboutFile.content);
            const aboutBytes = new Uint8Array(aboutBinaryString.length);
            for (let i = 0; i < aboutBinaryString.length; i++) {
              aboutBytes[i] = aboutBinaryString.charCodeAt(i);
            }
            const aboutContent = new TextDecoder('utf-8').decode(aboutBytes);
            aboutData = JSON.parse(aboutContent);
          } else {
            // If file doesn't exist, initialize with empty structure
            aboutData = { paragraphs: [] };
          }
        } catch (error) {
          console.warn('Failed to load about.json, initializing empty:', error);
          aboutData = { paragraphs: [] };
        }
        
        // Normalize data structure - ensure all albums use description.credits and description.paragraphs
        if (albumsData.albums && albumsData.albums.length > 0) {
          albumsData.albums.forEach((album, idx) => {
            // Ensure description exists
            if (!album.description) {
              album.description = { paragraphs: [], credits: {} };
            }
            
            // Move top-level paragraphs to description.paragraphs if they exist
            if (album.paragraphs && Array.isArray(album.paragraphs)) {
              if (!album.description.paragraphs || album.description.paragraphs.length === 0) {
                album.description.paragraphs = album.paragraphs;
              }
              delete album.paragraphs; // Remove top-level paragraphs
            }
            
            // Move top-level credits to description.credits if description.credits is empty or corrupted
            if (album.credits && typeof album.credits === 'object') {
              // Check if description.credits is empty or has suspiciously short values
              const hasValidDescriptionCredits = album.description.credits && 
                Object.keys(album.description.credits).length > 0 &&
                !Object.values(album.description.credits).some(arr => 
                  Array.isArray(arr) && arr.length > 0 && arr[0] && arr[0].length < 5
                );
              
              if (!hasValidDescriptionCredits && album.credits.artists && album.credits.artists.length > 0) {
                // Use top-level credits if description.credits is invalid
                album.description.credits = {
                  artists: album.credits.artists || [],
                  production: album.credits.production || [],
                  coverArt: album.credits.coverArt || [],
                  additional: album.credits.additional || []
                };
              }
              delete album.credits; // Remove top-level credits
            }
            
            // Ensure description.credits structure exists
            if (!album.description.credits) {
              album.description.credits = {
                artists: [],
                production: [],
                coverArt: [],
                additional: []
              };
            }
            
            // Clean up empty strings from credit arrays
            Object.keys(album.description.credits).forEach(key => {
              if (Array.isArray(album.description.credits[key])) {
                album.description.credits[key] = album.description.credits[key].filter(item => item && item.trim().length > 0);
              }
            });
          });
        }
        
        // Debug: Log the loaded data to check if it's already corrupted
        console.log('Loaded albumsData (after normalization):', albumsData);
        if (albumsData.albums && albumsData.albums.length > 0) {
          albumsData.albums.forEach((album, idx) => {
            if (album.description?.credits?.artists && album.description.credits.artists.length > 0) {
              const firstArtist = album.description.credits.artists[0];
              if (firstArtist && firstArtist.length < 5) {
                console.warn(`Album ${idx} has suspiciously short first artist credit: "${firstArtist}"`);
              }
            }
          });
        }
        
        renderAlbums();
        renderAbout();
        showStatus('Content loaded successfully', 'success');
      } catch (error) {
        showStatus('Error loading content: ' + error.message, 'error');
        console.error(error);
      }
    }
    
    function createNewAlbum() {
      if (!albumsData) {
        albumsData = { albums: [] };
      }
      
      // Find the highest ID and add 1
      const maxId = albumsData.albums.length > 0 
        ? Math.max(...albumsData.albums.map(a => a.id || 0))
        : 0;
      
      const newAlbum = {
        id: maxId + 1,
        urlPath: '',
        artist: '',
        title: '',
        releaseDate: new Date().toISOString().split('T')[0],
        cover: '',
        description: {
          paragraphs: [],
          credits: {
            artists: [],
            production: [],
            coverArt: [],
            additional: []
          }
        }
      };
      
      albumsData.albums.push(newAlbum);
      renderAlbums();
      showStatus('New album created. Fill in the details and save.', 'info');
      
      // Scroll to the new album
      setTimeout(() => {
        const items = document.querySelectorAll('.item-item');
        if (items.length > 0) {
          items[items.length - 1].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
      }, 100);
    }
    
    function deleteAlbum(index) {
      if (confirm('Are you sure you want to delete this album?')) {
        albumsData.albums.splice(index, 1);
        renderAlbums();
        showStatus('Album deleted. Remember to save changes.', 'info');
      }
    }
    
    function moveAlbum(index, direction) {
      if (direction === 'up' && index > 0) {
        [albumsData.albums[index], albumsData.albums[index - 1]] = 
          [albumsData.albums[index - 1], albumsData.albums[index]];
        renderAlbums();
      } else if (direction === 'down' && index < albumsData.albums.length - 1) {
        [albumsData.albums[index], albumsData.albums[index + 1]] = 
          [albumsData.albums[index + 1], albumsData.albums[index]];
        renderAlbums();
      }
    }
    
    function applySort() {
      if (!albumsData || !albumsData.albums || albumsData.albums.length === 0) {
        showStatus('No albums to sort', 'info');
        return;
      }
      
      // Show warning
      const warningDiv = document.getElementById('sort-warning');
      warningDiv.classList.add('show');
      
      // Confirm before sorting
      if (!confirm('Are you sure you want to reorder albums? The current manual ordering will be lost. You can undo this by refreshing the page before saving.')) {
        warningDiv.classList.remove('show');
        return;
      }
      
      const sortField = document.getElementById('sort-field').value;
      const sortOrder = document.getElementById('sort-order').value;
      
      // Save all current values before sorting
      saveAllCurrentValues();
      
      // Create a copy of albums for sorting
      const sortedAlbums = [...albumsData.albums];
      
      // Sort based on selected field
      sortedAlbums.sort((a, b) => {
        let aValue, bValue;
        
        switch (sortField) {
          case 'id':
            aValue = a.id || 0;
            bValue = b.id || 0;
            break;
          case 'releaseDate':
            aValue = a.releaseDate || '';
            bValue = b.releaseDate || '';
            break;
          case 'artist':
            aValue = (a.artist || '').toLowerCase();
            bValue = (b.artist || '').toLowerCase();
            break;
          case 'title':
            aValue = (a.title || '').toLowerCase();
            bValue = (b.title || '').toLowerCase();
            break;
          default:
            return 0;
        }
        
        // Compare values
        let comparison = 0;
        if (aValue < bValue) {
          comparison = -1;
        } else if (aValue > bValue) {
          comparison = 1;
        }
        
        // Apply sort order
        return sortOrder === 'asc' ? comparison : -comparison;
      });
      
      // Update albumsData with sorted array
      albumsData.albums = sortedAlbums;
      
      // Re-render albums
      renderAlbums();
      
      // Show success message
      showStatus(`Albums sorted by ${sortField} (${sortOrder === 'asc' ? 'ascending' : 'descending'}). Remember to save your changes.`, 'success');
      
      // Keep warning visible
      setTimeout(() => {
        warningDiv.classList.remove('show');
      }, 10000); // Hide warning after 10 seconds
    }
    
    function renderAlbums() {
      const container = document.getElementById('albums-list');
      container.innerHTML = '';
      
      if (!albumsData || !albumsData.albums || albumsData.albums.length === 0) {
        container.innerHTML = '<p style="color: #666; padding: 20px;">No albums yet. Click "Create New Album" to get started.</p>';
        return;
      }
      
      albumsData.albums.forEach((album, index) => {
        const albumDiv = document.createElement('div');
        albumDiv.className = 'item-item';
        albumDiv.setAttribute('data-index', index);
        
        const title = album.artist && album.title 
          ? `${album.artist} - ${album.title}`
          : 'New Album (untitled)';
        
        albumDiv.innerHTML = `
          <div class="item-header">
            <h3>${escapeHtml(title)}</h3>
            <div class="item-controls">
              <button class="btn btn-small" onclick="moveAlbum(${index}, 'up')" ${index === 0 ? 'disabled' : ''}>↑</button>
              <button class="btn btn-small" onclick="moveAlbum(${index}, 'down')" ${index === albumsData.albums.length - 1 ? 'disabled' : ''}>↓</button>
              <button class="btn btn-small btn-danger" onclick="deleteAlbum(${index})">Delete</button>
            </div>
          </div>
          <div class="meta">
            Release Date: ${album.releaseDate || 'Not set'} | 
            ${album.urlPath ? `<a href="${BASE_URL}/album/${escapeHtml(album.urlPath)}" target="_blank" style="color: #0c5460; text-decoration: underline;">${BASE_URL}/album/${escapeHtml(album.urlPath)}</a>` : 'URL: Not set'}
          </div>
          
          <div class="form-row">
            <div class="form-group">
              <label>ID <span style="color: #666; font-size: 12px;">(must be unique)</span></label>
              <input type="number" data-field="id" data-index="${index}" value="${album.id || ''}" min="1" onchange="validateAlbumId(${index}, this)">
              <div id="id-error-${index}" style="color: #dc3545; font-size: 12px; margin-top: 5px; display: none;"></div>
            </div>
            <div class="form-group">
              <label>Artist</label>
              <input type="text" data-field="artist" data-index="${index}" value="${escapeHtml(album.artist || '')}">
            </div>
          </div>
          
          <div class="form-row">
            <div class="form-group">
              <label>Title</label>
              <input type="text" data-field="title" data-index="${index}" value="${escapeHtml(album.title || '')}">
            </div>
            <div class="form-group"></div>
          </div>
          
          <div class="form-row">
            <div class="form-group">
              <label>URL Path <span style="color: #666; font-size: 12px;">(used in album URL)</span></label>
              <input type="text" data-field="urlPath" data-index="${index}" value="${escapeHtml(album.urlPath || '')}" placeholder="e.g., do-i-care" onchange="updateAlbumUrlPreview(${index})">
              <div id="url-preview-${index}" style="margin-top: 5px; font-size: 12px; color: #666;">
                ${album.urlPath ? `Full URL: <a href="${BASE_URL}/album/${escapeHtml(album.urlPath)}" target="_blank" style="color: #0c5460; text-decoration: underline;">${BASE_URL}/album/${escapeHtml(album.urlPath)}</a>` : 'Enter a URL path to see the full album URL'}
              </div>
            </div>
            <div class="form-group">
              <label>Release Date</label>
              <input type="date" data-field="releaseDate" data-index="${index}" value="${album.releaseDate || ''}">
            </div>
          </div>
          
          <div class="form-row">
            <div class="form-group">
              <label>Cover Image</label>
              <div style="display: flex; gap: 10px; align-items: flex-start;">
                <input type="text" data-field="cover" data-index="${index}" value="${escapeHtml(album.cover || '')}" style="flex: 1;">
                <input type="file" accept="image/*" data-index="${index}" id="cover-upload-${index}" style="display: none;" onchange="handleImageUpload(${index}, this)">
                <button type="button" class="btn btn-small" onclick="document.getElementById('cover-upload-${index}').click()">Upload</button>
              </div>
              <div id="cover-preview-${index}" style="margin-top: 10px;">
                ${album.cover ? `<img src="/orthodox-website/${album.cover}" alt="Cover preview" style="max-width: 200px; max-height: 200px; border: 1px solid #ddd; border-radius: 4px;" onerror="this.style.display='none'">` : ''}
              </div>
              <div id="cover-upload-status-${index}" style="margin-top: 5px; font-size: 12px;"></div>
            </div>
            <div class="form-group">
              <label>Bandcamp Embed ID</label>
              <input type="number" data-field="bandcampEmbedId" data-index="${index}" value="${album.bandcampEmbedId || ''}">
            </div>
          </div>
          
          <div class="form-group">
            <label>Description Paragraphs</label>
            <div id="paragraphs-${index}"></div>
            <button type="button" class="btn btn-small" onclick="addParagraph(${index})">Add Paragraph</button>
          </div>
          
          <div class="form-group">
            <label>Credits - Artists</label>
            <div id="artists-${index}"></div>
            <button type="button" class="btn btn-small" onclick="addCredit(${index}, 'artists')">Add Artist Credit</button>
          </div>
          
          <div class="form-group">
            <label>Credits - Production</label>
            <div id="production-${index}"></div>
            <button type="button" class="btn btn-small" onclick="addCredit(${index}, 'production')">Add Production Credit</button>
          </div>
          
          <div class="form-group">
            <label>Credits - Cover Art</label>
            <div id="coverArt-${index}"></div>
            <button type="button" class="btn btn-small" onclick="addCredit(${index}, 'coverArt')">Add Cover Art Credit</button>
          </div>
          
          <div class="form-group">
            <label>Credits - Additional</label>
            <div id="additional-${index}"></div>
            <button type="button" class="btn btn-small" onclick="addCredit(${index}, 'additional')">Add Additional Credit</button>
          </div>
        `;
        
        container.appendChild(albumDiv);
        
        // Render paragraphs
        renderList(`paragraphs-${index}`, album.description?.paragraphs || [], index, 'paragraphs');
        
        // Render credits
        if (!album.description) album.description = { paragraphs: [], credits: {} };
        if (!album.description.credits) album.description.credits = {};
        
        renderList(`artists-${index}`, album.description.credits?.artists || [], index, 'credits.artists');
        renderList(`production-${index}`, album.description.credits?.production || [], index, 'credits.production');
        renderList(`coverArt-${index}`, album.description.credits?.coverArt || [], index, 'credits.coverArt');
        renderList(`additional-${index}`, album.description.credits?.additional || [], index, 'credits.additional');
      });
      
      // Attach input listeners - only for top-level fields, not nested ones like credits
      container.querySelectorAll('input[data-field][data-index], textarea[data-field][data-index]').forEach(input => {
        const field = input.dataset.field;
        // Skip nested fields (like credits.artists) - those are handled by updateList
        if (field && !field.includes('.')) {
          input.addEventListener('change', updateAlbum);
        }
      });
    }
    
    function saveListValues(containerId, albumIndex, fieldPath) {
      const container = document.getElementById(containerId);
      if (!container) {
        // Container doesn't exist yet, nothing to save
        return;
      }
      
      // Save current input values before re-rendering
      // Read all inputs - use a more specific selector to ensure we get all inputs
      // Try multiple selectors to be thorough
      let inputs = Array.from(container.querySelectorAll('input[type="text"]'));
      
      // If no inputs found with that selector, try a broader search
      if (inputs.length === 0) {
        inputs = Array.from(container.querySelectorAll('input'));
      }
      
      if (inputs.length === 0) {
        // No inputs found - this could mean:
        // 1. The list is actually empty (user deleted all items)
        // 2. The container is being re-rendered and is temporarily empty
        // Only set to empty array if the container is actually empty (not just being re-rendered)
        // We'll let renderList handle the empty case, so we don't overwrite data here
        return;
      }
      
      // Filter and validate inputs - ensure they have data-item attribute
      // Note: data-item="0" is valid, so we check for undefined/null/empty string specifically
      const validInputs = inputs.filter(input => {
        const itemIndex = input.getAttribute('data-item');
        // Check if data-item exists (even if it's "0")
        return itemIndex !== null;
      });
      
      if (validInputs.length === 0) {
        console.warn(`No valid inputs found in ${containerId} for saving ${fieldPath}`);
        // No valid inputs found, skip saving to avoid overwriting with empty array
        return;
      }
      
      // Sort inputs by their item index to ensure correct order
      validInputs.sort((a, b) => {
        const indexA = parseInt(a.getAttribute('data-item')) || 0;
        const indexB = parseInt(b.getAttribute('data-item')) || 0;
        return indexA - indexB;
      });
      
      // Verify we have consecutive indices (0, 1, 2, ...) - if not, log a warning
      const indices = validInputs.map(input => parseInt(input.getAttribute('data-item')) || 0);
      const expectedIndices = Array.from({ length: validInputs.length }, (_, i) => i);
      const hasGaps = !indices.every((idx, i) => idx === expectedIndices[i]);
      if (hasGaps) {
        console.warn(`Warning: Input indices have gaps in ${containerId}:`, indices);
      }
      
      // Build array from DOM values - preserve empty strings but ensure we get the full value
      const values = validInputs.map((input, idx) => {
        // Get the value directly from the input element's value property
        // This is the most reliable way to get the current value
        let val = input.value;
        
        // If value is null/undefined, use empty string
        if (val === null || val === undefined) {
          val = '';
        }
        
        // Convert to string to ensure we have a string value
        val = String(val);
        
        // Debug: Log detailed info for suspicious values (first item only, and only if very short)
        if (val.length > 0 && val.length < 5 && idx === 0) {
          console.warn(`Warning: First value in ${fieldPath} for album ${albumIndex} seems short: "${val}"`, {
            inputValue: input.value,
            inputValueLength: input.value?.length || 0,
            defaultValue: input.defaultValue,
            attributeValue: input.getAttribute('value'),
            maxLength: input.maxLength,
            dataItem: input.getAttribute('data-item')
          });
          
          // If we detect a suspiciously short value, also log all inputs to see what's happening
          console.log('All inputs in container:', Array.from(container.querySelectorAll('input[type="text"]')).map(inp => ({
            dataItem: inp.getAttribute('data-item'),
            value: inp.value,
            valueLength: inp.value?.length || 0
          })));
        }
        
        return val;
      });
      
      // Debug logging - log the actual values being saved with detailed info
      const currentDataValue = (() => {
        const paths = (fieldPath === 'paragraphs' ? 'description.paragraphs' : fieldPath).split('.');
        let target = albumsData.albums[albumIndex];
        for (let i = 0; i < paths.length - 1; i++) {
          if (paths[i] === 'description') target = target?.description;
          else if (paths[i] === 'credits') target = target?.credits;
          else target = target?.[paths[i]];
        }
        return target?.[paths[paths.length - 1]];
      })();
      
      console.log(`Saving ${fieldPath} for album ${albumIndex}:`, {
        inputCount: validInputs.length,
        values: values,
        firstValueLength: values[0]?.length || 0,
        firstValue: values[0],
        // Compare with what's in albumsData
        currentDataValue: currentDataValue,
        dataMatches: JSON.stringify(currentDataValue) === JSON.stringify(values)
      });
      
      // Handle special case for 'paragraphs' field path
      let actualPath = fieldPath;
      if (fieldPath === 'paragraphs') {
        actualPath = 'description.paragraphs';
      }
      
      const paths = actualPath.split('.');
      let target = albumsData.albums[albumIndex];
      
      if (!target) {
        console.error(`Album at index ${albumIndex} not found`);
        return;
      }
      
      // Ensure description exists
      if (paths[0] === 'description' || paths.includes('description')) {
        if (!target.description) {
          target.description = { paragraphs: [], credits: {} };
        }
      }
      
      // Navigate through the path
      for (let i = 0; i < paths.length - 1; i++) {
        if (paths[i] === 'description') {
          target = target.description;
          if (!target) {
            target = { paragraphs: [], credits: {} };
            albumsData.albums[albumIndex].description = target;
          }
        } else if (paths[i] === 'credits') {
          if (!target.credits) {
            target.credits = {};
          }
          target = target.credits;
        } else {
          if (!target[paths[i]]) {
            target[paths[i]] = {};
          }
          target = target[paths[i]];
        }
      }
      
      // Replace the entire array with values from DOM
      const finalKey = paths[paths.length - 1];
      target[finalKey] = values;
    }
    
    function renderList(containerId, items, albumIndex, fieldPath) {
      const container = document.getElementById(containerId);
      if (!container) return;
      
      // Save current values before clearing
      saveListValues(containerId, albumIndex, fieldPath);
      
      container.innerHTML = '';
      
      items.forEach((item, itemIndex) => {
        const div = document.createElement('div');
        div.className = 'list-item';
        
        // Ensure item is a string and not null/undefined
        const itemValue = (item !== null && item !== undefined) ? String(item) : '';
        
        // Debug: Log if we're rendering a suspiciously short value
        if (itemValue.length > 0 && itemValue.length < 5 && itemIndex === 0 && fieldPath.includes('credits')) {
          console.warn(`Rendering short value for ${fieldPath}[${itemIndex}]: "${itemValue}"`, {
            originalItem: item,
            itemType: typeof item,
            itemLength: itemValue.length,
            albumIndex,
            fieldPath
          });
        }
        
        // Create input element properly to avoid HTML attribute issues
        const input = document.createElement('input');
        input.type = 'text';
        input.setAttribute('data-album', albumIndex !== null ? albumIndex : '');
        input.setAttribute('data-field', fieldPath);
        input.setAttribute('data-item', itemIndex);
        input.value = itemValue; // Set value directly, not via HTML attribute
        
        // Verify the value was set correctly
        if (input.value !== itemValue) {
          console.error(`Value mismatch when setting input: expected "${itemValue}", got "${input.value}"`);
          input.value = itemValue; // Force set again
        }
        
        input.onchange = function() { updateList(this); };
        
        // Create remove button
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'btn btn-small btn-danger';
        removeBtn.textContent = 'Remove';
        if (fieldPath === 'about-paragraphs') {
          removeBtn.onclick = function() { removeAboutParagraph(itemIndex); };
        } else {
          removeBtn.onclick = function() { removeListItem(albumIndex, fieldPath, itemIndex); };
        }
        
        div.appendChild(input);
        div.appendChild(removeBtn);
        container.appendChild(div);
      });
    }
    
    function renderAbout() {
      if (!aboutData) {
        aboutData = { paragraphs: [] };
      }
      
      if (!aboutData.paragraphs) {
        aboutData.paragraphs = [];
      }
      
      renderList('about-paragraphs', aboutData.paragraphs, null, 'about-paragraphs');
    }
    
    function addAboutParagraph() {
      if (!aboutData) {
        aboutData = { paragraphs: [] };
      }
      
      if (!aboutData.paragraphs) {
        aboutData.paragraphs = [];
      }
      
      // Get current values from DOM before modifying
      const container = document.getElementById('about-paragraphs');
      if (container) {
        const inputs = Array.from(container.querySelectorAll('input[type="text"]'));
        const currentValues = inputs.map(input => input.value);
        
        // Update the data structure with current DOM values
        aboutData.paragraphs = currentValues;
      }
      
      // Add new empty paragraph
      aboutData.paragraphs.push('');
      
      // Re-render the list
      renderList('about-paragraphs', aboutData.paragraphs, null, 'about-paragraphs');
    }
    
    function removeAboutParagraph(itemIndex) {
      // Save current values before removing
      saveListValues('about-paragraphs', null, 'about-paragraphs');
      
      if (aboutData && aboutData.paragraphs) {
        aboutData.paragraphs.splice(itemIndex, 1);
        renderList('about-paragraphs', aboutData.paragraphs, null, 'about-paragraphs');
      }
    }
    
    function addParagraph(albumIndex) {
      if (!albumsData.albums[albumIndex].description) {
        albumsData.albums[albumIndex].description = { paragraphs: [], credits: {} };
      }
      if (!albumsData.albums[albumIndex].description.paragraphs) {
        albumsData.albums[albumIndex].description.paragraphs = [];
      }
      
      // Get current values from DOM before modifying
      const container = document.getElementById(`paragraphs-${albumIndex}`);
      if (container) {
        const inputs = Array.from(container.querySelectorAll('input[type="text"]'));
        const currentValues = inputs.map(input => input.value);
        
        // Update the data structure with current DOM values
        albumsData.albums[albumIndex].description.paragraphs = currentValues;
      }
      
      // Add new empty paragraph
      albumsData.albums[albumIndex].description.paragraphs.push('');
      
      // Re-render the list
      renderList(`paragraphs-${albumIndex}`, albumsData.albums[albumIndex].description.paragraphs, albumIndex, 'paragraphs');
    }
    
    function addCredit(albumIndex, creditType) {
      if (!albumsData.albums[albumIndex].description) {
        albumsData.albums[albumIndex].description = { paragraphs: [], credits: {} };
      }
      if (!albumsData.albums[albumIndex].description.credits) {
        albumsData.albums[albumIndex].description.credits = {};
      }
      if (!albumsData.albums[albumIndex].description.credits[creditType]) {
        albumsData.albums[albumIndex].description.credits[creditType] = [];
      }
      
      // Get current values from DOM before modifying - this ensures we capture any unsaved edits
      const container = document.getElementById(`${creditType}-${albumIndex}`);
      let currentValues = [];
      if (container) {
        const inputs = Array.from(container.querySelectorAll('input[type="text"]'));
        // Sort by data-item index to ensure correct order - use getAttribute to handle "0" correctly
        inputs.sort((a, b) => {
          const indexA = parseInt(a.getAttribute('data-item')) || 0;
          const indexB = parseInt(b.getAttribute('data-item')) || 0;
          return indexA - indexB;
        });
        currentValues = inputs.map(input => {
          const val = input.value;
          return (val !== null && val !== undefined) ? String(val) : '';
        });
        
        // Debug: Log if we're reading suspicious values
        if (currentValues.length > 0 && currentValues[0] && currentValues[0].length < 5) {
          console.warn(`addCredit: Reading short first value for ${creditType}: "${currentValues[0]}"`, {
            allValues: currentValues,
            inputCount: inputs.length
          });
        }
      } else {
        // If container doesn't exist, use existing values from data
        currentValues = albumsData.albums[albumIndex].description.credits[creditType] || [];
      }
      
      // Update the data structure with current DOM values
      albumsData.albums[albumIndex].description.credits[creditType] = currentValues;
      
      // Add new empty credit
      albumsData.albums[albumIndex].description.credits[creditType].push('');
      
      // Re-render the list (renderList will call saveListValues, but we've already synced, so it's safe)
      renderList(`${creditType}-${albumIndex}`, albumsData.albums[albumIndex].description.credits[creditType], albumIndex, `credits.${creditType}`);
    }
    
    function removeListItem(albumIndex, fieldPath, itemIndex) {
      // Determine the container ID based on field path
      const lastPath = fieldPath.split('.').pop();
      const containerId = `${lastPath}-${albumIndex}`;
      
      // Save current values before removing
      saveListValues(containerId, albumIndex, fieldPath);
      
      const paths = fieldPath.split('.');
      let target = albumsData.albums[albumIndex];
      
      for (let i = 0; i < paths.length - 1; i++) {
        if (paths[i] === 'description') {
          target = target.description;
        } else if (paths[i] === 'credits') {
          if (!target.credits) return;
          target = target.credits;
        } else {
          if (!target[paths[i]]) return;
          target = target[paths[i]];
        }
      }
      
      if (target[paths[paths.length - 1]]) {
        target[paths[paths.length - 1]].splice(itemIndex, 1);
        renderList(containerId, target[paths[paths.length - 1]], albumIndex, fieldPath);
      }
    }
    
    function updateAlbum(event) {
      const field = event.target.dataset.field;
      const index = parseInt(event.target.dataset.index);
      
      // Safety check
      if (!field || index === undefined || index === null || !albumsData.albums[index]) {
        console.error('Invalid updateAlbum call:', { field, index, album: albumsData.albums[index] });
        return;
      }
      
      // Skip nested fields (like credits.artists) - those should use updateList
      if (field.includes('.')) {
        console.warn('updateAlbum called for nested field, should use updateList:', field);
        return;
      }
      
      const value = event.target.type === 'number' ? (event.target.value ? parseInt(event.target.value) : undefined) : event.target.value;
      
      albumsData.albums[index][field] = value;
      
      // Update URL preview if urlPath changed
      if (field === 'urlPath') {
        updateAlbumUrlPreview(index);
      }
    }
    
    function updateAlbumUrlPreview(index) {
      const urlPath = albumsData.albums[index].urlPath || '';
      const previewDiv = document.getElementById(`url-preview-${index}`);
      if (previewDiv) {
        if (urlPath) {
          const fullUrl = `${BASE_URL}/album/${escapeHtml(urlPath)}`;
          previewDiv.innerHTML = `Full URL: <a href="${fullUrl}" target="_blank" style="color: #0c5460; text-decoration: underline;">${fullUrl}</a>`;
          } else {
          previewDiv.innerHTML = 'Enter a URL path to see the full album URL';
        }
      }
      
      // Also update the meta line
      const albumDiv = document.querySelector(`.item-item[data-index="${index}"]`);
      if (albumDiv) {
        const metaDiv = albumDiv.querySelector('.meta');
        if (metaDiv) {
          const album = albumsData.albums[index];
          const releaseDate = album.releaseDate || 'Not set';
          const urlPart = urlPath 
            ? `<a href="${BASE_URL}/album/${escapeHtml(urlPath)}" target="_blank" style="color: #0c5460; text-decoration: underline;">${BASE_URL}/album/${escapeHtml(urlPath)}</a>`
            : 'URL: Not set';
          metaDiv.innerHTML = `Release Date: ${releaseDate} | ${urlPart}`;
        }
      }
    }
    
    window.updateAlbumUrlPreview = updateAlbumUrlPreview;
    
    window.updateList = function(input) {
      // Use getAttribute to handle "0" correctly
      const albumIndexAttr = input.getAttribute('data-album');
      const albumIndex = albumIndexAttr !== null && albumIndexAttr !== '' ? parseInt(albumIndexAttr) : null;
      const fieldPath = input.getAttribute('data-field');
      const itemIndex = parseInt(input.getAttribute('data-item')) || 0;
      const value = input.value || '';
      
      // Handle about page paragraphs
      if (fieldPath === 'about-paragraphs') {
        if (!aboutData) {
          aboutData = { paragraphs: [] };
        }
        if (!aboutData.paragraphs) {
          aboutData.paragraphs = [];
        }
        while (aboutData.paragraphs.length <= itemIndex) {
          aboutData.paragraphs.push('');
        }
        aboutData.paragraphs[itemIndex] = value;
        return;
      }
      
      // Debug: Log if we're updating with a suspiciously short value
      if (value.length > 0 && value.length < 5 && itemIndex === 0 && fieldPath && fieldPath.includes('credits')) {
        console.warn(`updateList: Updating with short value for ${fieldPath}[${itemIndex}]: "${value}"`, {
          inputValue: input.value,
          inputValueLength: input.value?.length || 0,
          albumIndex,
          fieldPath,
          itemIndex
        });
      }
      
      // Skip if albumIndex is null
      if (albumIndex === null || albumIndex === undefined) {
        return;
      }
      
      const paths = fieldPath.split('.');
      let target = albumsData.albums[albumIndex];
      
      if (!target.description) target.description = { paragraphs: [], credits: {} };
      
      for (let i = 0; i < paths.length - 1; i++) {
        if (paths[i] === 'description') {
          target = target.description;
          if (!target) {
            target = { paragraphs: [], credits: {} };
            albumsData.albums[albumIndex].description = target;
          }
        } else if (paths[i] === 'credits') {
          if (!target.credits) target.credits = {};
          target = target.credits;
        } else {
          if (!target[paths[i]]) {
            target[paths[i]] = {};
          }
          target = target[paths[i]];
        }
      }
      
      const finalKey = paths[paths.length - 1];
      if (!target[finalKey]) {
        target[finalKey] = [];
      }
      
      // Ensure array is long enough before setting value
      const array = target[finalKey];
      while (array.length <= itemIndex) {
        array.push('');
      }
      
      array[itemIndex] = value;
    };
    
    window.removeListItem = removeListItem;
    window.addParagraph = addParagraph;
    window.addAboutParagraph = addAboutParagraph;
    window.addCredit = addCredit;
    window.deleteAlbum = deleteAlbum;
    window.moveAlbum = moveAlbum;
    
    async function handleImageUpload(albumIndex, fileInput) {
      const file = fileInput.files[0];
      if (!file) return;
      
      // Validate file type
      if (!file.type.startsWith('image/')) {
        showStatus('Please select an image file', 'error');
        return;
      }
      
      // Validate file size (max 10MB)
      if (file.size > 10 * 1024 * 1024) {
        showStatus('Image file is too large. Maximum size is 10MB.', 'error');
        return;
      }
      
      const statusDiv = document.getElementById(`cover-upload-status-${albumIndex}`);
      statusDiv.textContent = 'Uploading...';
      statusDiv.style.color = '#0c5460';
      
      try {
        // Generate filename from album URL path or use sanitized original filename
        let filename;
        const album = albumsData.albums[albumIndex];
        if (album.urlPath) {
          const ext = file.name.split('.').pop();
          filename = `${album.urlPath.replace(/[^a-z0-9-]/gi, '_').toLowerCase()}.${ext}`;
        } else {
          // Sanitize filename
          filename = file.name.replace(/[^a-z0-9.-]/gi, '_').toLowerCase();
        }
        
        const filePath = `public/${filename}`;
        
        // Read file as base64
        const reader = new FileReader();
        reader.onload = async function(e) {
          try {
            const base64Content = e.target.result.split(',')[1]; // Remove data:image/...;base64, prefix
            
            // Check if file already exists
            let sha = null;
            try {
              const existingFile = await fetch(`https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${filePath}`, {
                headers: {
                  'Authorization': `token ${token}`,
                  'Accept': 'application/vnd.github.v3+json'
                }
              });
              
              if (existingFile.ok) {
                const existing = await existingFile.json();
                sha = existing.sha;
                    }
                  } catch (e) {
              // File doesn't exist, that's fine
            }
            
            // Upload file to GitHub
            const uploadResponse = await fetch(`https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${filePath}`, {
              method: 'PUT',
              headers: {
                'Authorization': `token ${token}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                message: `Upload cover image: ${filename}`,
                content: base64Content,
                sha: sha,
                branch: BRANCH
              })
            });
            
            if (!uploadResponse.ok) {
              const error = await uploadResponse.json().catch(() => ({}));
              throw new Error(error.message || 'Failed to upload image');
            }
            
            // Update cover field
            albumsData.albums[albumIndex].cover = filename;
            const coverInput = document.querySelector(`input[data-field="cover"][data-index="${albumIndex}"]`);
            if (coverInput) {
              coverInput.value = filename;
            }
            
            // Update preview
            const previewDiv = document.getElementById(`cover-preview-${albumIndex}`);
            if (previewDiv) {
              const existingImg = previewDiv.querySelector('img');
              if (existingImg) {
                existingImg.src = `/orthodox-website/${filename}`;
                existingImg.style.display = 'block';
              } else {
                const img = document.createElement('img');
                img.src = `/orthodox-website/${filename}`;
                img.alt = 'Cover preview';
                img.style.cssText = 'max-width: 200px; max-height: 200px; border: 1px solid #ddd; border-radius: 4px;';
                img.onerror = function() { this.style.display = 'none'; };
                previewDiv.appendChild(img);
              }
            }
            
            statusDiv.textContent = 'Uploaded successfully!';
            statusDiv.style.color = '#155724';
            showStatus('Image uploaded successfully!', 'success');
            
            // Reset file input
            fileInput.value = '';
          } catch (error) {
            statusDiv.textContent = 'Upload failed: ' + error.message;
            statusDiv.style.color = '#721c24';
            showStatus('Error uploading image: ' + error.message, 'error');
            console.error(error);
          }
        };
        
        reader.readAsDataURL(file);
      } catch (error) {
        statusDiv.textContent = 'Error: ' + error.message;
        statusDiv.style.color = '#721c24';
        showStatus('Error uploading image: ' + error.message, 'error');
        console.error(error);
      }
    }
    
    window.handleImageUpload = handleImageUpload;
    
    function saveAllCurrentValues() {
      // Save all regular input fields
      document.querySelectorAll('input[data-field][data-index], textarea[data-field][data-index]').forEach(input => {
        const field = input.dataset.field;
        const index = parseInt(input.dataset.index);
        const value = input.type === 'number' 
          ? (input.value ? parseInt(input.value) : undefined) 
          : input.value;
        
        if (field === 'id') {
          // ID is handled separately with validation
          return;
        }
        
        if (albumsData.albums[index]) {
          albumsData.albums[index][field] = value;
        }
      });
      
      // Save all list values (paragraphs and credits) - ensure we save in the correct order
      // CRITICAL: Save ALL list values from DOM before saving to ensure we capture any unsaved edits
      albumsData.albums.forEach((album, index) => {
        // Always try to save - saveListValues will check if container exists
        // This ensures we capture values even if user hasn't blurred inputs yet
        saveListValues(`paragraphs-${index}`, index, 'paragraphs');
        saveListValues(`artists-${index}`, index, 'credits.artists');
        saveListValues(`production-${index}`, index, 'credits.production');
        saveListValues(`coverArt-${index}`, index, 'credits.coverArt');
        saveListValues(`additional-${index}`, index, 'credits.additional');
      });
      
      // Save about page paragraphs
      saveListValues('about-paragraphs', null, 'about-paragraphs');
    }
    
    document.getElementById('save-btn').addEventListener('click', async () => {
      try {
        // Debug: Log albumsData before saving to see if it's already corrupted
        console.log('albumsData before saveAllCurrentValues:', JSON.parse(JSON.stringify(albumsData)));
        
        // Save all current values from the DOM before saving
        saveAllCurrentValues();
        
        // Debug: Log albumsData after saving to see what changed
        console.log('albumsData after saveAllCurrentValues:', JSON.parse(JSON.stringify(albumsData)));
        
        // Validate IDs are unique
        const ids = albumsData.albums.map(a => a.id).filter(id => id !== undefined && id !== null);
        const duplicateIds = ids.filter((id, index) => ids.indexOf(id) !== index);
        if (duplicateIds.length > 0) {
          showStatus(`Error: Duplicate IDs found: ${duplicateIds.join(', ')}. Please ensure all IDs are unique.`, 'error');
          return;
        }
        
        const saveBtn = document.getElementById('save-btn');
        const originalText = saveBtn.textContent;
        saveBtn.disabled = true;
        saveBtn.textContent = 'Saving...';
        
        // Show toast notification
        const savingToast = showToast(
          'Saving Changes',
          'Uploading changes to GitHub...',
          'info',
          0 // Don't auto-close
        );
        
        // Save albums data
        const albumsFileResponse = await fetch(`https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${ALBUMS_FILE_PATH}`, {
          headers: {
            'Authorization': `token ${token}`,
            'Accept': 'application/vnd.github.v3+json'
          }
        });
        
        const albumsFile = await albumsFileResponse.json();
        const albumsSha = albumsFile.sha;
        
        // Update albums file - ensure proper UTF-8 encoding
        const albumsContent = JSON.stringify(albumsData, null, 2);
        const albumsEncoder = new TextEncoder();
        const albumsBytes = albumsEncoder.encode(albumsContent);
        const albumsBinaryString = String.fromCharCode(...albumsBytes);
        const albumsEncodedContent = btoa(albumsBinaryString);
        
        const albumsUpdateResponse = await fetch(`https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${ALBUMS_FILE_PATH}`, {
          method: 'PUT',
          headers: {
            'Authorization': `token ${token}`,
            'Accept': 'application/vnd.github.v3+json',
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            message: 'Update albums data via admin',
            content: albumsEncodedContent,
            sha: albumsSha,
            branch: BRANCH
          })
        });
        
        if (!albumsUpdateResponse.ok) {
          const error = await albumsUpdateResponse.json().catch(() => ({}));
          throw new Error(error.message || `Failed to save albums: ${albumsUpdateResponse.status} ${albumsUpdateResponse.statusText}`);
        }
        
        // Save about data - fetch SHA AFTER albums save to ensure we have the latest
        if (aboutData) {
          // Fetch fresh SHA right before saving to avoid stale SHA issues
          let aboutSha = null;
          try {
            const aboutFileResponse = await fetch(`https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${ABOUT_FILE_PATH}`, {
              headers: {
                'Authorization': `token ${token}`,
                'Accept': 'application/vnd.github.v3+json'
              }
            });
            
            if (aboutFileResponse.ok) {
              const aboutFile = await aboutFileResponse.json();
              aboutSha = aboutFile.sha;
            }
          } catch (error) {
            // File doesn't exist yet, that's fine
            console.log('About file does not exist yet, will create it');
          }
          
          const aboutContent = JSON.stringify(aboutData, null, 2);
          const aboutEncoder = new TextEncoder();
          const aboutBytes = aboutEncoder.encode(aboutContent);
          const aboutBinaryString = String.fromCharCode(...aboutBytes);
          const aboutEncodedContent = btoa(aboutBinaryString);
          
          const aboutUpdateResponse = await fetch(`https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${ABOUT_FILE_PATH}`, {
            method: 'PUT',
            headers: {
              'Authorization': `token ${token}`,
              'Accept': 'application/vnd.github.v3+json',
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              message: 'Update about page data via admin',
              content: aboutEncodedContent,
              sha: aboutSha,
              branch: BRANCH
            })
          });
          
          if (!aboutUpdateResponse.ok) {
            const error = await aboutUpdateResponse.json().catch(() => ({}));
            // If it's a SHA mismatch error, provide helpful message
            if (error.message && error.message.includes('sha')) {
              throw new Error(`Failed to save about page: SHA mismatch. This usually means the file was changed. Please refresh and try again.`);
            }
            throw new Error(error.message || `Failed to save about page: ${aboutUpdateResponse.status} ${aboutUpdateResponse.statusText}`);
          }
        }
        
        // Dismiss the saving toast
        if (savingToast) {
          dismissToast(savingToast);
        }
        
        // Reload content to ensure we have the latest data and avoid stale state
        // This prevents issues where subsequent saves use stale SHAs
        try {
          await loadContent();
        } catch (reloadError) {
          console.warn('Failed to reload content after save:', reloadError);
          // Don't fail the save if reload fails, just log it
        }
        
        // Show commit success toast (auto-dismisses after 5 seconds)
        showToast(
          'Changes Committed',
          'Your changes have been successfully committed to GitHub.',
          'success',
          5000
        );
        
        // Show deployment monitoring toast (separate toast)
        const deploymentToast = showToast(
          'Deployment Status',
          'Checking deployment status...',
          'info',
          0 // Don't auto-dismiss, we'll handle it in monitorDeployment
        );
        
        // Start monitoring GitHub Actions deployment status
        setTimeout(() => monitorDeployment(deploymentToast), 2000); // Wait 2 seconds for workflow to start
        
        saveBtn.disabled = false;
        saveBtn.textContent = originalText;
        showStatus('Changes saved successfully! Monitoring deployment status...', 'success');
      } catch (error) {
        const saveBtn = document.getElementById('save-btn');
        saveBtn.disabled = false;
        saveBtn.textContent = 'Save All Changes';
        
        // Remove saving toast if it exists
        const savingToast = document.querySelector('.toast.info');
        if (savingToast) {
          savingToast.remove();
        }
        
        // Show error toast
        showToast(
          'Save Failed',
          error.message || 'An error occurred while saving changes.',
          'error',
          0 // Don't auto-close errors
        );
        
        showStatus('Error saving: ' + error.message, 'error');
        console.error(error);
      }
    });
    
    function validateAlbumId(albumIndex, input) {
      const newId = parseInt(input.value);
      const errorDiv = document.getElementById(`id-error-${albumIndex}`);
      
      if (!newId || newId < 1) {
        errorDiv.textContent = 'ID must be a positive number';
        errorDiv.style.display = 'block';
        input.style.borderColor = '#dc3545';
        return false;
      }
      
      // Check for duplicates
      const duplicates = albumsData.albums.filter((album, index) => 
        album.id === newId && index !== albumIndex
      );
      
      if (duplicates.length > 0) {
        errorDiv.textContent = `ID ${newId} is already used by another album`;
        errorDiv.style.display = 'block';
        input.style.borderColor = '#dc3545';
        return false;
      }
      
      errorDiv.style.display = 'none';
      input.style.borderColor = '#ddd';
      albumsData.albums[albumIndex].id = newId;
      return true;
    }
    
    window.validateAlbumId = validateAlbumId;
    
    function showStatus(message, type) {
      const statusDiv = document.getElementById('status');
      statusDiv.textContent = message;
      statusDiv.className = `status ${type}`;
      statusDiv.classList.remove('hidden');
      
      if (type === 'success') {
        setTimeout(() => {
          statusDiv.classList.add('hidden');
        }, 3000);
      }
    }
    
    function showToast(title, message, type = 'info', duration = 5000) {
      const container = document.getElementById('toast-container');
      if (!container) return;
      
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      
      const icons = {
        success: '✓',
        error: '✕',
        info: 'ℹ',
        warning: '⚠'
      };
      
      toast.innerHTML = `
        <span class="toast-icon">${icons[type] || icons.info}</span>
        <div class="toast-content">
          <div class="toast-title">${escapeHtml(title)}</div>
          <div class="toast-message">${escapeHtml(message)}</div>
        </div>
        <button class="toast-close" onclick="dismissToast(this.parentElement)">×</button>
      `;
      
      container.appendChild(toast);
      
      // Auto-remove after duration (unless it's an error, which stays until manually closed)
      if (type !== 'error' && duration > 0) {
        setTimeout(() => {
          dismissToast(toast);
        }, duration);
      }
      
      return toast;
    }
    
    function dismissToast(toast) {
      if (toast && toast.parentElement) {
        toast.classList.add('dismissing');
        setTimeout(() => {
          if (toast.parentElement) {
            toast.remove();
          }
        }, 300);
      }
    }
    
    window.dismissToast = dismissToast;
    
    async function checkGitHubActionsStatus() {
      try {
        // Get the latest workflow run for the repository
        const response = await fetch(`https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/actions/runs?per_page=1`, {
          headers: {
            'Authorization': `token ${token}`,
            'Accept': 'application/vnd.github.v3+json'
          }
        });
        
        if (!response.ok) {
          return null;
        }
        
        const data = await response.json();
        if (data.workflow_runs && data.workflow_runs.length > 0) {
          const run = data.workflow_runs[0];
          return {
            status: run.status, // queued, in_progress, completed
            conclusion: run.conclusion, // success, failure, cancelled, etc.
            html_url: run.html_url,
            created_at: run.created_at,
            updated_at: run.updated_at
          };
        }
        return null;
      } catch (error) {
        console.error('Error checking GitHub Actions status:', error);
        return null;
      }
    }
    
    async function monitorDeployment(toastElement) {
      const maxChecks = 30; // Check for up to 5 minutes (30 checks * 10 seconds)
      let checkCount = 0;
      
      const checkInterval = setInterval(async () => {
        checkCount++;
        const status = await checkGitHubActionsStatus();
        
        if (!status) {
          // Can't get status, stop checking
          clearInterval(checkInterval);
          return;
        }
        
        // Ensure deployment status div exists
        let statusDivEl = toastElement.querySelector('.deployment-status');
        if (!statusDivEl) {
          statusDivEl = document.createElement('div');
          statusDivEl.className = 'deployment-status active';
          toastElement.querySelector('.toast-content').appendChild(statusDivEl);
        }
        if (statusDivEl) {
          if (status.status === 'completed') {
            clearInterval(checkInterval);
            
            if (status.conclusion === 'success') {
              // Update toast to show success
              toastElement.className = 'toast success';
              toastElement.querySelector('.toast-icon').textContent = '✓';
              toastElement.querySelector('.toast-icon').style.color = '#28a745';
              toastElement.querySelector('.toast-title').textContent = 'Deployment Completed';
              toastElement.querySelector('.toast-message').textContent = 'Your changes are now live on the website!';
              
              statusDivEl.innerHTML = `
                <a href="${status.html_url}" target="_blank" class="deployment-status-link">View workflow →</a>
              `;
              
              // Auto-dismiss after 5 seconds
              setTimeout(() => {
                dismissToast(toastElement);
              }, 5000);
            } else if (status.conclusion === 'failure') {
              // Update toast to show error
              toastElement.className = 'toast error';
              toastElement.querySelector('.toast-icon').textContent = '✕';
              toastElement.querySelector('.toast-icon').style.color = '#dc3545';
              toastElement.querySelector('.toast-title').textContent = 'Deployment Failed';
              toastElement.querySelector('.toast-message').textContent = 'Deployment failed. Check workflow for details.';
              
              statusDivEl.innerHTML = `
                <a href="${status.html_url}" target="_blank" class="deployment-status-link">View workflow →</a>
              `;
              
              // Auto-dismiss after 5 seconds
              setTimeout(() => {
                dismissToast(toastElement);
              }, 5000);
            } else {
              // Other conclusion (cancelled, etc.)
              toastElement.className = 'toast warning';
              toastElement.querySelector('.toast-icon').textContent = '⚠';
              toastElement.querySelector('.toast-icon').style.color = '#ffc107';
              toastElement.querySelector('.toast-title').textContent = 'Deployment Status';
              toastElement.querySelector('.toast-message').textContent = `Deployment ${status.conclusion || 'completed'}.`;
              
              statusDivEl.innerHTML = `
                <a href="${status.html_url}" target="_blank" class="deployment-status-link">View workflow →</a>
              `;
              
              // Auto-dismiss after 5 seconds
              setTimeout(() => {
                dismissToast(toastElement);
              }, 5000);
            }
          } else if (status.status === 'in_progress' || status.status === 'queued') {
            statusDivEl.innerHTML = `
              <span class="deployment-spinner"></span>
              <span>Deployment in progress... (checking ${checkCount}/${maxChecks})</span>
              <a href="${status.html_url}" target="_blank" class="deployment-status-link">View workflow →</a>
            `;
          }
        }
        
        // Stop checking after max attempts
        if (checkCount >= maxChecks) {
          clearInterval(checkInterval);
          if (statusDivEl) {
            toastElement.querySelector('.toast-title').textContent = 'Deployment Status';
            toastElement.querySelector('.toast-message').textContent = 'Still deploying... Check back in a few minutes.';
            statusDivEl.innerHTML = `
              <a href="${status.html_url || '#'}" target="_blank" class="deployment-status-link">View workflow →</a>
            `;
            
            // Auto-dismiss after 5 seconds
            setTimeout(() => {
              dismissToast(toastElement);
            }, 5000);
          }
        }
      }, 10000); // Check every 10 seconds
    }
    
    function escapeHtml(text) {
      if (text === null || text === undefined) return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
  </script>
</body>
</html>
