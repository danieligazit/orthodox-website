<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Content Manager</title>
  <!-- Point Decap CMS to the config file -->
  <link href="/orthodox-website/admin/config.yml" type="text/yaml" rel="cms-config-url" />
  <style>
    /* Hide login button when user is authenticated */
    body:has([data-netlify-cms] [class*="Login"]) [data-netlify-cms] [class*="Login"] {
      display: none !important;
    }
    /* Show CMS content when authenticated */
    [data-netlify-cms] [class*="cms-content"],
    [data-netlify-cms] [class*="CMS-content"] {
      display: block !important;
    }
  </style>
</head>
<body>
  <!-- Handle OAuth callback token -->
  <script>
    // Read token from URL and make it available to Decap CMS
    const urlParams = new URLSearchParams(window.location.search);
    const accessToken = urlParams.get('access_token');
    
    if (accessToken) {
      // Store token for Decap CMS
      localStorage.setItem('netlify-cms-auth-token', accessToken);
      
      // Clean up URL - remove query params but keep hash if present
      const cleanUrl = window.location.pathname + (window.location.hash || '');
      window.history.replaceState({}, document.title, cleanUrl);
      
      // Force page reload to ensure Decap CMS picks up the token
      // Note: reload() stops execution automatically, no return needed
      window.location.reload();
    }
  </script>
  
  <script>
    // Intercept ALL network requests BEFORE Decap CMS loads to ensure token is always sent
    // This must run before Decap CMS initializes
    (function() {
      // Store original fetch immediately
      const originalFetch = window.fetch;
      
      // Override fetch to add Authorization header for proxy requests
      window.fetch = function(url, options = {}) {
        // Always check for token (in case it was just stored)
        const token = localStorage.getItem('netlify-cms-auth-token');
        
        // If this is a request to our OAuth proxy, add the token
        if (token && typeof url === 'string' && url.includes('decap-oauth-proxy')) {
          options = options || {};
          
          // Handle both Headers object and plain object
          if (options.headers instanceof Headers) {
            if (!options.headers.has('Authorization')) {
              options.headers.set('Authorization', `token ${token}`);
            }
          } else {
            options.headers = options.headers || {};
            // Check both cases
            if (!options.headers['Authorization'] && !options.headers['authorization']) {
              options.headers['Authorization'] = `token ${token}`;
            }
          }
        }
        
        return originalFetch.call(this, url, options);
      };
      
      // Also intercept XMLHttpRequest (some libraries use this instead of fetch)
      const originalXHROpen = XMLHttpRequest.prototype.open;
      const originalXHRSend = XMLHttpRequest.prototype.send;
      const originalXHRSetRequestHeader = XMLHttpRequest.prototype.setRequestHeader;
      
      XMLHttpRequest.prototype.open = function(method, url, ...args) {
        this._url = url;
        return originalXHROpen.apply(this, [method, url, ...args]);
      };
      
      XMLHttpRequest.prototype.setRequestHeader = function(name, value) {
        // Store headers to check later
        if (!this._headers) {
          this._headers = {};
        }
        this._headers[name.toLowerCase()] = value;
        return originalXHRSetRequestHeader.apply(this, arguments);
      };
      
      XMLHttpRequest.prototype.send = function(...args) {
        const token = localStorage.getItem('netlify-cms-auth-token');
        if (token && this._url && this._url.includes('decap-oauth-proxy')) {
          // Check if Authorization header is already set
          if (!this._headers || !this._headers['authorization']) {
            originalXHRSetRequestHeader.call(this, 'Authorization', `token ${token}`);
          }
        }
        return originalXHRSend.apply(this, args);
      };
    })();
  </script>
  
  <script>
    // Intercept backend registration BEFORE Decap CMS loads
    // This ensures our override is in place before Decap CMS initializes
    (function() {
      const token = localStorage.getItem('netlify-cms-auth-token');
      
      if (!token) {
        return;
      }
      
      // Store original registerBackend if it exists
      const originalRegisterBackend = window.CMS && window.CMS.registerBackend;
      
      // Override registerBackend to intercept GitHub backend registration
      if (window.CMS) {
        const originalRegister = window.CMS.registerBackend;
        window.CMS.registerBackend = function(name, BackendClass) {
          const result = originalRegister.apply(this, arguments);
          
          // If this is the GitHub backend, wrap its methods immediately
          if (name === 'github') {
            setTimeout(function() {
              try {
                const backend = window.CMS.getBackend('github');
                if (backend && !backend._authOverrideSet) {
                  setupBackendAuth(backend);
                }
              } catch (e) {
                console.log('Error setting up backend auth:', e);
              }
            }, 0);
          }
          
          return result;
        };
      }
    })();
  </script>
  
  <!-- Include Decap CMS -->
  <script src="https://unpkg.com/decap-cms@^3.1.2/dist/decap-cms.js"></script>
  
  <script>
    // Function to set up backend authentication
    function setupBackendAuth(backend) {
      if (backend._authOverrideSet) {
        return;
      }
      
      backend._authOverrideSet = true;
      const token = localStorage.getItem('netlify-cms-auth-token');
      
      if (!token) {
        return;
      }
      
      // Store original methods
      const originalRestoreUser = backend.restoreUser;
      const originalAuthenticate = backend.authenticate;
      
      // Pre-fetch and cache user data immediately
      // This ensures restoreUser can return synchronously when Decap CMS calls it
      const proxyUrl = 'https://decap-oauth-proxy.danieligazit.workers.dev';
      fetch(`${proxyUrl}/user`, {
        headers: {
          'Authorization': `token ${token}`
        }
      })
      .then(response => {
        if (response.ok) {
          return response.json().then(userData => {
            const user = {
              token: token,
              name: userData.login || userData.name,
              login: userData.login,
              avatar_url: userData.avatar_url,
              email: userData.email
            };
            
            // Cache user for immediate return in restoreUser
            // This will be set by the restoreUser override above
            console.log('Pre-authenticated user:', user);
            
            // Set currentUser immediately so Decap CMS sees authenticated state
            backend.currentUser = user;
            if (backend.user !== undefined) {
              backend.user = user;
            }
          });
        }
      })
      .catch(err => {
        console.log('Pre-auth check failed, will retry:', err);
      });
      
      // Cache user data to return immediately
      let cachedUser = null;
      
      // Override restoreUser - return cached user immediately if available
      backend.restoreUser = function() {
        const storedToken = localStorage.getItem('netlify-cms-auth-token');
        if (!storedToken) {
          cachedUser = null;
          backend.currentUser = null;
          return originalRestoreUser ? originalRestoreUser.call(this) : Promise.reject('No token');
        }
        
        // If we have cached user, return it immediately (synchronous-like behavior)
        if (cachedUser && cachedUser.token === storedToken) {
          backend.currentUser = cachedUser;
          if (backend.user !== undefined) {
            backend.user = cachedUser;
          }
          return Promise.resolve(cachedUser);
        }
        
        // Otherwise fetch and cache
        const proxyUrl = 'https://decap-oauth-proxy.danieligazit.workers.dev';
        return fetch(`${proxyUrl}/user`, {
          headers: {
            'Authorization': `token ${storedToken}`
          }
        })
        .then(response => {
          if (response.ok) {
            return response.json().then(userData => {
              const user = {
                token: storedToken,
                name: userData.login || userData.name,
                login: userData.login,
                avatar_url: userData.avatar_url,
                email: userData.email
              };
              
              // Cache the user
              cachedUser = user;
              
              // Set currentUser on backend so Decap CMS recognizes authentication
              backend.currentUser = user;
              
              // Also try to set it on the backend's user property if it exists
              if (backend.user !== undefined) {
                backend.user = user;
              }
              
              return user;
            });
          } else {
            cachedUser = null;
            localStorage.removeItem('netlify-cms-auth-token');
            backend.currentUser = null;
            if (backend.user !== undefined) {
              backend.user = null;
            }
            throw new Error('Token invalid');
          }
        })
        .catch(error => {
          console.error('Token verification failed:', error);
          cachedUser = null;
          backend.currentUser = null;
          if (backend.user !== undefined) {
            backend.user = null;
          }
          return originalRestoreUser ? originalRestoreUser.call(this) : Promise.reject(error);
        });
      };
      
      // Override authenticate - CRITICAL: Don't trigger OAuth if we have a token
      backend.authenticate = function() {
        const storedToken = localStorage.getItem('netlify-cms-auth-token');
        if (storedToken) {
          // If we have a token, just restore the user - don't trigger OAuth
          console.log('Authenticate called with existing token, restoring user...');
          return backend.restoreUser().then(function(user) {
            console.log('Authenticate restored user:', user);
            return user;
          });
        }
        // Only trigger OAuth if we don't have a token
        console.log('No token found, triggering OAuth...');
        return originalAuthenticate ? originalAuthenticate.call(this) : Promise.reject('No token');
      };
    }
    
    // Configure Decap CMS authentication after it loads
    (function() {
      const token = localStorage.getItem('netlify-cms-auth-token');
      
      if (!token) {
        return;
      }
      
      function setupAuth() {
        const CMS = window.CMS || window.netlifyCMS;
        if (!CMS) return false;
        
        try {
          const backend = CMS.getBackend('github');
          if (!backend) {
            return false;
          }
          
          setupBackendAuth(backend);
          
          // Call restoreUser to ensure authentication state is set
          // Decap CMS should call this automatically during init, but we call it too
          const authPromise = backend.restoreUser()
            .then(function(user) {
              console.log('User authenticated:', user);
              
              // Try to manually trigger Decap CMS authentication flow
              // This simulates what happens when user clicks "Login with GitHub"
              setTimeout(function() {
                try {
                  const CMS = window.CMS || window.netlifyCMS;
                  
                  // Try to access the CMS app instance
                  if (CMS.getApp) {
                    const app = CMS.getApp();
                    if (app && app.store) {
                      // Dispatch authentication success action
                      app.store.dispatch({ type: 'AUTHENTICATION_SUCCESS', user: user });
                      
                      // Also try to dispatch a user received action
                      app.store.dispatch({ type: 'USER_RECEIVED', user: user });
                      
                      // Try to dispatch LOGIN_SUCCESS
                      app.store.dispatch({ type: 'LOGIN_SUCCESS', user: user });
                      
                      // Try to set auth state directly
                      if (app.store.getState) {
                        const state = app.store.getState();
                        if (state.auth) {
                          app.store.dispatch({ 
                            type: 'AUTHENTICATE_USER_SUCCESS', 
                            user: user,
                            token: user.token 
                          });
                        }
                      }
                    }
                  }
                  
                  // Try to access the backend's status and force it to update
                  const backend = CMS.getBackend('github');
                  if (backend) {
                    // Set the user on the backend
                    backend.currentUser = user;
                    backend.user = user;
                    
                    // Try to call any status/check methods
                    if (typeof backend.status === 'function') {
                      backend.status();
                    }
                    if (typeof backend.checkBackendHealth === 'function') {
                      backend.checkBackendHealth();
                    }
                    
                    // Try calling authenticate again to trigger UI update
                    if (backend.currentUser) {
                      backend.authenticate().catch(() => {});
                    }
                  }
                  
                  // Try to find and trigger the authentication component
                  // Decap CMS uses React, so we might need to trigger a re-render
                  const rootElement = document.getElementById('nc-root') || document.querySelector('[data-netlify-cms]');
                  if (rootElement) {
                    // Trigger a custom event that might cause re-render
                    const event = new CustomEvent('netlify-cms-auth-success', { 
                      detail: { user: user },
                      bubbles: true 
                    });
                    rootElement.dispatchEvent(event);
                  }
                } catch (e) {
                  console.log('Could not force UI update:', e);
                }
              }, 100);
              
              // Also try after a longer delay in case CMS is still initializing
              setTimeout(function() {
                try {
                  const CMS = window.CMS || window.netlifyCMS;
                  const backend = CMS.getBackend('github');
                  if (backend && backend.currentUser) {
                    // Try to trigger authentication again
                    backend.authenticate().then(function(u) {
                      console.log('Re-authenticated:', u);
                    }).catch(function(e) {
                      console.log('Re-auth failed:', e);
                    });
                  }
                  
                  // Check if login button is still visible and try to hide it or trigger auth
                  const loginButton = document.querySelector('button[class*="Login"], a[class*="Login"], [class*="login-button"], button:contains("Login"), a:contains("Login")');
                  if (loginButton && backend && backend.currentUser) {
                    console.log('Login button still visible, attempting to force authentication state...');
                    
                    // Try to access React internals to force state update
                    try {
                      // Find React root and force update
                      const reactRoot = loginButton._reactInternalFiber || loginButton._reactInternalInstance;
                      if (reactRoot) {
                        // Try to find the component and force update
                        let fiber = reactRoot;
                        while (fiber) {
                          if (fiber.memoizedState || fiber.stateNode) {
                            const component = fiber.stateNode;
                            if (component && typeof component.forceUpdate === 'function') {
                              component.forceUpdate();
                            }
                          }
                          fiber = fiber.return;
                        }
                      }
                    } catch (e) {
                      console.log('Could not access React internals:', e);
                    }
                    
                    // Hide the login button and show CMS content instead
                    loginButton.style.display = 'none';
                    
                    // Try to find and show the CMS content area
                    const cmsContent = document.querySelector('[class*="cms"], [class*="CMS"], [id*="cms"]');
                    if (cmsContent) {
                      cmsContent.style.display = 'block';
                    }
                    
                    // Force a page refresh as last resort
                    setTimeout(function() {
                      if (document.querySelector('button[class*="Login"], a[class*="Login"]')) {
                        console.log('Login button still visible after attempts, refreshing page...');
                        window.location.reload();
                      }
                    }, 3000);
                  }
                } catch (e) {
                  console.log('Delayed auth update failed:', e);
                }
              }, 2000);
              
              // One more attempt after even longer delay
              setTimeout(function() {
                try {
                  const CMS = window.CMS || window.netlifyCMS;
                  const backend = CMS.getBackend('github');
                  if (backend && backend.currentUser) {
                    // Force a full re-authentication
                    backend.authenticate().then(function(u) {
                      console.log('Final re-authentication:', u);
                    });
                  }
                } catch (e) {
                  console.log('Final auth attempt failed:', e);
                }
              }, 5000);
            })
            .catch(function(error) {
              console.log('Authentication check failed:', error);
            });
          
          // Also ensure currentUser is set even if restoreUser hasn't completed
          if (backend.currentUser) {
            // User already set, try to trigger update
            setTimeout(function() {
              try {
                const CMS = window.CMS || window.netlifyCMS;
                if (CMS.getApp) {
                  const app = CMS.getApp();
                  if (app && app.store) {
                    app.store.dispatch({ type: 'AUTHENTICATION_SUCCESS', user: backend.currentUser });
                  }
                }
              } catch (e) {
                console.log('Could not trigger update with existing user:', e);
              }
            }, 100);
          }
          
          return true;
        } catch (error) {
          console.error('Error configuring Decap CMS authentication:', error);
          return false;
        }
      }
      
      // Try immediately
      if (!setupAuth()) {
        let checkCount = 0;
        const maxChecks = 200;
        
        const checkInterval = setInterval(function() {
          checkCount++;
          if (setupAuth() || checkCount >= maxChecks) {
            clearInterval(checkInterval);
          }
        }, 50);
      }
      
      window.addEventListener('DOMContentLoaded', setupAuth);
      setTimeout(setupAuth, 1000);
      
      // Watch for login button appearing and auto-authenticate if we have a token
      // Reuse the token variable from the outer scope
      if (token) {
        const observer = new MutationObserver(function(mutations) {
          const loginButton = document.querySelector('button[class*="Login"], a[class*="Login"], button:contains("Login"), a:contains("Login"), [aria-label*="Login"], [title*="Login"]');
          if (loginButton) {
            console.log('Login button detected, checking authentication...');
            const CMS = window.CMS || window.netlifyCMS;
            if (CMS) {
              const backend = CMS.getBackend('github');
              if (backend && backend.currentUser) {
                console.log('User already authenticated, hiding login button...');
                loginButton.style.display = 'none';
                loginButton.remove();
                
                // Try to trigger CMS to show content
                setTimeout(function() {
                  backend.authenticate().then(function(user) {
                    console.log('Auto-authenticated via observer:', user);
                  });
                }, 100);
              }
            }
          }
        });
        
        // Start observing
        observer.observe(document.body, {
          childList: true,
          subtree: true,
          attributes: true,
          attributeFilter: ['class', 'style']
        });
        
        // Also check immediately
        setTimeout(function() {
          const loginButton = document.querySelector('button[class*="Login"], a[class*="Login"], [aria-label*="Login"], [title*="Login"]');
          if (loginButton) {
            const CMS = window.CMS || window.netlifyCMS;
            if (CMS) {
              const backend = CMS.getBackend('github');
              if (backend && backend.currentUser) {
                loginButton.style.display = 'none';
                loginButton.remove();
              }
            }
          }
        }, 2000);
      }
    })();
  </script>
</body>
</html>