<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Content Manager</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: #f5f5f5;
      padding: 20px;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      padding: 30px;
    }
    
    h1 {
      margin-bottom: 30px;
      color: #333;
    }
    
    .auth-section {
      text-align: center;
      padding: 40px;
    }
    
    /* Tabs */
    .tabs {
      display: flex;
      gap: 10px;
      border-bottom: 2px solid #e0e0e0;
      margin-bottom: 30px;
    }
    
    .tab {
      padding: 12px 24px;
      background: none;
      border: none;
      border-bottom: 3px solid transparent;
      cursor: pointer;
      font-size: 16px;
      font-weight: 500;
      color: #666;
      transition: all 0.2s;
    }
    
    .tab:hover {
      color: #333;
    }
    
    .tab.active {
      color: #24292e;
      border-bottom-color: #24292e;
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    .btn {
      background: #24292e;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 500;
      transition: background 0.2s;
    }
    
    .btn:hover {
      background: #2f363d;
    }
    
    .btn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    
    .btn-success {
      background: #28a745;
    }
    
    .btn-success:hover {
      background: #218838;
    }
    
    .btn-primary {
      background: #007bff;
    }
    
    .btn-primary:hover {
      background: #0056b3;
    }
    
    .status {
      padding: 12px;
      border-radius: 6px;
      margin: 20px 0;
    }
    
    .status.success {
      background: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }
    
    .status.error {
      background: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }
    
    .status.info {
      background: #d1ecf1;
      color: #0c5460;
      border: 1px solid #bee5eb;
    }
    
    /* Toast Notification System */
    .toast-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 10000;
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-width: 400px;
    }
    
    .toast {
      background: white;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      padding: 16px 20px;
      display: flex;
      align-items: flex-start;
      gap: 12px;
      animation: slideIn 0.3s ease-out;
      min-width: 300px;
      max-width: 400px;
    }
    
    .toast.success {
      border-left: 4px solid #28a745;
    }
    
    .toast.error {
      border-left: 4px solid #dc3545;
    }
    
    .toast.info {
      border-left: 4px solid #17a2b8;
    }
    
    .toast.warning {
      border-left: 4px solid #ffc107;
    }
    
    .toast-icon {
      font-size: 20px;
      flex-shrink: 0;
      margin-top: 2px;
    }
    
    .toast.success .toast-icon {
      color: #28a745;
    }
    
    .toast.error .toast-icon {
      color: #dc3545;
    }
    
    .toast.info .toast-icon {
      color: #17a2b8;
    }
    
    .toast.warning .toast-icon {
      color: #ffc107;
    }
    
    .toast-content {
      flex: 1;
    }
    
    .toast-title {
      font-weight: 600;
      margin-bottom: 4px;
      color: #333;
    }
    
    .toast-message {
      font-size: 14px;
      color: #666;
      line-height: 1.4;
    }
    
    .toast-close {
      background: none;
      border: none;
      font-size: 20px;
      color: #999;
      cursor: pointer;
      padding: 0;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }
    
    .toast-close:hover {
      color: #333;
    }
    
    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    
    @keyframes fadeOut {
      from {
        opacity: 1;
        transform: translateX(0);
      }
      to {
        opacity: 0;
        transform: translateX(100%);
      }
    }
    
    .toast.dismissing {
      animation: fadeOut 0.3s ease-out forwards;
    }
    
    .deployment-status {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid #e0e0e0;
      font-size: 12px;
      color: #666;
    }
    
    .deployment-status.active {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .deployment-spinner {
      width: 12px;
      height: 12px;
      border: 2px solid #e0e0e0;
      border-top-color: #17a2b8;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .deployment-status-link {
      color: #17a2b8;
      text-decoration: none;
    }
    
    .deployment-status-link:hover {
      text-decoration: underline;
    }
    
    .items-list {
      margin-top: 30px;
    }
    
    .item-item {
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 20px;
      margin-bottom: 20px;
      background: #fafafa;
      position: relative;
    }
    
    .item-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    
    .item-header h3 {
      margin: 0;
      color: #333;
    }
    
    .item-controls {
      display: flex;
      gap: 5px;
    }
    
    .item-controls button {
      padding: 6px 12px;
      font-size: 14px;
    }
    
    .item-item .meta {
      color: #666;
      font-size: 14px;
      margin-bottom: 15px;
    }
    
    .form-group {
      margin-bottom: 15px;
    }
    
    .form-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
      color: #333;
    }
    
    .form-group input,
    .form-group textarea {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      font-family: inherit;
    }
    
    .form-group textarea {
      min-height: 100px;
      resize: vertical;
    }
    
    .form-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
    }
    
    .list-item {
      background: white;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 10px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .list-item input {
      flex: 1;
      border: none;
      padding: 5px;
    }
    
    .btn-small {
      padding: 6px 12px;
      font-size: 14px;
    }
    
    .btn-danger {
      background: #dc3545;
    }
    
    .btn-danger:hover {
      background: #c82333;
    }
    
    .hidden {
      display: none;
    }
    
    .page-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    
    .user-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 1px solid #e0e0e0;
    }
    
    .user-info {
      display: flex;
      align-items: center;
      gap: 10px;
      color: #666;
      font-size: 14px;
    }
    
    .btn-outline {
      background: white;
      color: #24292e;
      border: 1px solid #24292e;
    }
    
    .btn-outline:hover {
      background: #f5f5f5;
    }
    
    .sort-controls {
      display: flex;
      align-items: center;
      gap: 15px;
      margin-bottom: 20px;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 6px;
      border: 1px solid #e0e0e0;
    }
    
    .sort-controls label {
      font-weight: 500;
      color: #333;
      margin: 0;
    }
    
    .sort-controls select {
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      font-family: inherit;
      background: white;
      cursor: pointer;
    }
    
    .sort-controls select:focus {
      outline: none;
      border-color: #24292e;
    }
    
    .sort-warning {
      background: #fff3cd;
      color: #856404;
      border: 1px solid #ffc107;
      border-radius: 6px;
      padding: 12px 16px;
      margin-bottom: 20px;
      display: none;
    }
    
    .sort-warning.show {
      display: block;
    }
    
    .sort-warning-icon {
      font-weight: bold;
      margin-right: 8px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Content Manager</h1>
    
    <div id="auth-section" class="auth-section">
      <p>Please authenticate with GitHub to manage content.</p>
      <button id="login-btn" class="btn">Login with GitHub</button>
    </div>
    
    <div id="content-section" class="hidden">
      <div id="status"></div>
      <div id="toast-container" class="toast-container"></div>
      
      <div class="user-header">
        <div class="user-info">
          <span>Logged in as: <strong id="user-name">-</strong></span>
        </div>
        <button id="logout-btn" class="btn btn-outline">Logout</button>
      </div>
      
      <div class="tabs">
        <button class="tab active" data-tab="albums">Albums</button>
        <button class="tab" data-tab="about">About</button>
        <button class="tab" data-tab="press">Press Items</button>
      </div>
      
      <!-- Albums Tab -->
      <div id="albums-tab" class="tab-content active">
        <div class="page-header">
          <h2>Albums</h2>
          <button id="create-album-btn" class="btn btn-primary">Create New Album</button>
        </div>
        <div class="sort-controls">
          <label for="sort-field">Sort by:</label>
          <select id="sort-field">
            <option value="id">ID</option>
            <option value="releaseDate">Release Date</option>
            <option value="artist">Artist Name</option>
            <option value="title">Title</option>
          </select>
          <label for="sort-order">Order:</label>
          <select id="sort-order">
            <option value="asc">Ascending</option>
            <option value="desc">Descending</option>
          </select>
          <button id="apply-sort-btn" class="btn">Apply Sort</button>
        </div>
        <div id="sort-warning" class="sort-warning">
          <span class="sort-warning-icon">⚠</span>
          <strong>Warning:</strong> Applying a sort will permanently change the order of albums. The current manual ordering will be lost. Make sure to save your changes after sorting.
        </div>
        <div id="albums-list" class="items-list"></div>
      </div>
      
      <!-- About Tab -->
      <div id="about-tab" class="tab-content">
        <div class="page-header">
          <h2>About Page</h2>
        </div>
        <div id="about-content" class="form-container">
          <div class="form-group">
            <label>Paragraphs</label>
            <div id="about-paragraphs"></div>
            <button type="button" class="btn btn-small" onclick="addAboutParagraph()">Add Paragraph</button>
          </div>
        </div>
      </div>
      
      <!-- Press Items Tab -->
      <div id="press-tab" class="tab-content">
        <div class="page-header">
          <h2>Press Items</h2>
          <button id="create-press-btn" class="btn btn-primary">Create New Press Item</button>
        </div>
        <div class="sort-controls">
          <label for="press-sort-field">Sort by:</label>
          <select id="press-sort-field">
            <option value="id">ID</option>
            <option value="date">Date</option>
            <option value="title">Title</option>
          </select>
          <label for="press-sort-order">Order:</label>
          <select id="press-sort-order">
            <option value="asc">Ascending</option>
            <option value="desc">Descending</option>
          </select>
          <button id="apply-press-sort-btn" class="btn">Apply Sort</button>
        </div>
        <div id="press-sort-warning" class="sort-warning">
          <span class="sort-warning-icon">⚠</span>
          <strong>Warning:</strong> Applying a sort will permanently change the order of press items. The current manual ordering will be lost. Make sure to save your changes after sorting.
        </div>
        <div id="press-list" class="items-list"></div>
      </div>
      
      <button id="save-btn" class="btn btn-success" style="margin-top: 20px;">Save All Changes</button>
    </div>
  </div>

  <script>
    const PROXY_URL = 'https://decap-oauth-proxy.danieligazit.workers.dev';
    const REPO_OWNER = 'danieligazit';
    const REPO_NAME = 'orthodox-website';
    const ALBUMS_FILE_PATH = 'src/data/albums.json';
    const ABOUT_FILE_PATH = 'src/data/about.json';
    const PRESS_FILE_PATH = 'src/data/press.json';
    const BRANCH = 'main';
    const BASE_URL = 'https://danieligazit.github.io/orthodox-website';
    
    let token = localStorage.getItem('github-token');
    let albumsData = null;
    let aboutData = null;
    let pressData = { items: [] };
    
    // Tab switching
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        const tabName = tab.dataset.tab;
        
        // Update tabs
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        
        // Update content
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        document.getElementById(`${tabName}-tab`).classList.add('active');
      });
    });
    
    // Check for OAuth callback
    const urlParams = new URLSearchParams(window.location.search);
    const accessToken = urlParams.get('access_token');
    
    const storedToken = localStorage.getItem('github-token');
    
    if (accessToken) {
      // Update token if a new one is provided (handles token refresh)
      token = accessToken;
      localStorage.setItem('github-token', token);
      // Clear URL params immediately
      window.history.replaceState({}, document.title, window.location.pathname);
      // Verify token and load content
      verifyToken();
    } else if (token) {
      verifyToken();
    }
    
    document.getElementById('login-btn').addEventListener('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      
      // Add timestamp and random state to prevent caching and ensure fresh OAuth flow
      const timestamp = Date.now();
      const randomState = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
      
      // Disable button to prevent double-clicks
      const btn = document.getElementById('login-btn');
      btn.disabled = true;
      btn.textContent = 'Redirecting...';
      
      // Add prompt=login to force re-authentication
      window.location.href = `${PROXY_URL}/auth?t=${timestamp}&state=${randomState}&force=true&prompt=login`;
    });
    
    document.getElementById('create-album-btn').addEventListener('click', createNewAlbum);
    document.getElementById('create-press-btn').addEventListener('click', createNewPressItem);
    
    document.getElementById('apply-sort-btn').addEventListener('click', applySort);
    document.getElementById('apply-press-sort-btn').addEventListener('click', applyPressSort);
    
    document.getElementById('logout-btn').addEventListener('click', async () => {
      if (confirm('Log out?\n\nThis will revoke your GitHub authorization and log you out completely. You will need to sign in again the next time you access the admin panel.')) {
        const tokenToRevoke = token;
        
        // Clear all state immediately
        localStorage.removeItem('github-token');
        token = null;
        albumsData = null;
        aboutData = null;
        pressData = { items: [] };
        hasWritePermission = false;
        currentUsername = null;
        
        // Clear any status messages
        const statusDiv = document.getElementById('status');
        statusDiv.classList.add('hidden');
        statusDiv.textContent = '';
        
        // Hide content and show auth
        document.getElementById('auth-section').classList.remove('hidden');
        document.getElementById('content-section').classList.add('hidden');
        document.getElementById('user-name').textContent = '-';
        
        // Clear URL parameters
        window.history.replaceState({}, document.title, window.location.pathname);
        
        // Try to revoke the token (don't wait for it to complete)
        if (tokenToRevoke) {
          fetch(`${PROXY_URL}/revoke`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ token: tokenToRevoke }),
          }).catch(() => {
            // Ignore errors - token might already be revoked or expired
          });
        }
        
        showStatus('Logged out successfully. Click login to sign in again.', 'success');
      }
    });
    
    let hasWritePermission = false;
    let currentUsername = null;
    
    async function checkPermissions(username) {
      try {
        // Repository owner always has write permission
        if (username === REPO_OWNER) {
          hasWritePermission = true;
          return true;
        }
        
        // Check if user has write/admin permission to the repository
        const permResponse = await fetch(`${PROXY_URL}/repos/${REPO_OWNER}/${REPO_NAME}/collaborators/${username}/permission`, {
          headers: {
            'Authorization': `token ${token}`,
            'Accept': 'application/vnd.github.v3+json'
          }
        });
        
        if (permResponse.ok) {
          const permData = await permResponse.json();
          // User has write or admin permission
          hasWritePermission = permData.permission === 'write' || permData.permission === 'admin';
          return hasWritePermission;
        } else if (permResponse.status === 404) {
          // User is not a collaborator
          hasWritePermission = false;
          return false;
        } else {
          // Other error - assume no permission to be safe
          hasWritePermission = false;
          return false;
        }
      } catch (error) {
        console.error('Error checking permissions:', error);
        // If we can't check, assume no permission to be safe
        hasWritePermission = false;
        return false;
      }
    }
    
    async function verifyToken() {
      try {
        const response = await fetch(`${PROXY_URL}/user`, {
          headers: { 'Authorization': `token ${token}` }
        });
        
        if (response.ok) {
          const user = await response.json();
          currentUsername = user.login;
          document.getElementById('user-name').textContent = user.login;
          
          // Check permissions
          const hasPermission = await checkPermissions(user.login);
          
          if (hasPermission) {
            showStatus(`Logged in as ${user.login}`, 'success');
            // Show edit controls
            document.getElementById('save-btn').style.display = 'block';
            document.getElementById('create-album-btn').style.display = 'block';
            loadContent();
          } else {
            // User doesn't have write permission
            document.getElementById('auth-section').classList.add('hidden');
            document.getElementById('content-section').classList.remove('hidden');
            
            // Hide edit controls
            document.getElementById('save-btn').style.display = 'none';
            document.getElementById('create-album-btn').style.display = 'none';
            
            document.getElementById('albums-list').innerHTML = `
              <div style="padding: 40px; text-align: center; color: #721c24; background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 4px; margin: 20px;">
                <h2 style="margin-top: 0;">Access Denied</h2>
                <p>You are logged in as <strong>${user.login}</strong>, but you do not have write permissions to this repository.</p>
                <p>Only collaborators with write or admin access can view and edit content.</p>
                <p style="margin-top: 20px; font-size: 14px; color: #856404;">
                  If you believe you should have access, please contact the repository owner to add you as a collaborator.
                </p>
              </div>
            `;
            showStatus('You do not have permission to access this admin panel.', 'error');
          }
      } else {
          // Token is invalid or expired
          throw new Error('Token invalid');
        }
      } catch (error) {
        // Clear invalid token and show login screen
        localStorage.removeItem('github-token');
        token = null;
        document.getElementById('auth-section').classList.remove('hidden');
        document.getElementById('content-section').classList.add('hidden');
        document.getElementById('user-name').textContent = '-';
        showStatus('Session expired or invalid. Please login again.', 'error');
      }
    }
    
    async function loadContent() {
      // Only load content if user has write permission
      if (!hasWritePermission) {
        return;
      }
      
      document.getElementById('auth-section').classList.add('hidden');
      document.getElementById('content-section').classList.remove('hidden');
      
      try {
        showStatus('Loading content...', 'info');
        
        // Load albums
        const albumsResponse = await fetch(`${PROXY_URL}/repos/${REPO_OWNER}/${REPO_NAME}/contents/${ALBUMS_FILE_PATH}`, {
          headers: {
            'Authorization': `token ${token}`,
            'Accept': 'application/vnd.github.v3+json'
          }
        });
        
        if (!albumsResponse.ok) {
          const errorData = await albumsResponse.json().catch(() => ({}));
          throw new Error(errorData.message || `Failed to fetch albums: ${albumsResponse.status} ${albumsResponse.statusText}`);
        }
        
        const albumsFile = await albumsResponse.json();
        const albumsBinaryString = atob(albumsFile.content);
        const albumsBytes = new Uint8Array(albumsBinaryString.length);
        for (let i = 0; i < albumsBinaryString.length; i++) {
          albumsBytes[i] = albumsBinaryString.charCodeAt(i);
        }
        const albumsContent = new TextDecoder('utf-8').decode(albumsBytes);
        albumsData = JSON.parse(albumsContent);
        
        // Load about page
        try {
          const aboutResponse = await fetch(`${PROXY_URL}/repos/${REPO_OWNER}/${REPO_NAME}/contents/${ABOUT_FILE_PATH}`, {
            headers: {
              'Authorization': `token ${token}`,
              'Accept': 'application/vnd.github.v3+json'
            }
          });
          
          if (aboutResponse.ok) {
            const aboutFile = await aboutResponse.json();
            const aboutBinaryString = atob(aboutFile.content);
            const aboutBytes = new Uint8Array(aboutBinaryString.length);
            for (let i = 0; i < aboutBinaryString.length; i++) {
              aboutBytes[i] = aboutBinaryString.charCodeAt(i);
            }
            const aboutContent = new TextDecoder('utf-8').decode(aboutBytes);
            aboutData = JSON.parse(aboutContent);
          } else {
            // If file doesn't exist, initialize with empty structure
            aboutData = { paragraphs: [] };
          }
        } catch (error) {
          console.warn('Failed to load about.json, initializing empty:', error);
          aboutData = { paragraphs: [] };
        }
        
        // Load press items
        try {
          const pressResponse = await fetch(`${PROXY_URL}/repos/${REPO_OWNER}/${REPO_NAME}/contents/${PRESS_FILE_PATH}`, {
            headers: {
              'Authorization': `token ${token}`,
              'Accept': 'application/vnd.github.v3+json'
            }
          });
          
          if (pressResponse.ok) {
            const pressFile = await pressResponse.json();
            const pressBinaryString = atob(pressFile.content);
            const pressBytes = new Uint8Array(pressBinaryString.length);
            for (let i = 0; i < pressBinaryString.length; i++) {
              pressBytes[i] = pressBinaryString.charCodeAt(i);
            }
            const pressContent = new TextDecoder('utf-8').decode(pressBytes);
            pressData = JSON.parse(pressContent);
          } else {
            // If file doesn't exist, initialize with empty structure
            pressData = { items: [] };
          }
        } catch (error) {
          console.warn('Failed to load press.json, initializing empty:', error);
          pressData = { items: [] };
        }
        
        // Normalize data structure - ensure all albums use description.credits and description.paragraphs
        if (albumsData.albums && albumsData.albums.length > 0) {
          albumsData.albums.forEach((album, idx) => {
            // Ensure description exists
            if (!album.description) {
              album.description = { paragraphs: [], credits: {} };
            }
            
            // Move top-level paragraphs to description.paragraphs if they exist
            if (album.paragraphs && Array.isArray(album.paragraphs)) {
              if (!album.description.paragraphs || album.description.paragraphs.length === 0) {
                album.description.paragraphs = album.paragraphs;
              }
              delete album.paragraphs; // Remove top-level paragraphs
            }
            
            // Move top-level credits to description.credits if description.credits is empty or corrupted
            if (album.credits && typeof album.credits === 'object') {
              // Check if description.credits is empty or has suspiciously short values
              const hasValidDescriptionCredits = album.description.credits && 
                Object.keys(album.description.credits).length > 0 &&
                !Object.values(album.description.credits).some(arr => 
                  Array.isArray(arr) && arr.length > 0 && arr[0] && arr[0].length < 5
                );
              
              if (!hasValidDescriptionCredits && album.credits.artists && album.credits.artists.length > 0) {
                // Use top-level credits if description.credits is invalid
                album.description.credits = {
                  artists: album.credits.artists || [],
                  production: album.credits.production || [],
                  coverArt: album.credits.coverArt || [],
                  additional: album.credits.additional || []
                };
              }
              delete album.credits; // Remove top-level credits
            }
            
            // Ensure description.credits structure exists
            if (!album.description.credits) {
              album.description.credits = {
                artists: [],
                production: [],
                coverArt: [],
                additional: []
              };
            }
            
            // Clean up empty strings from credit arrays
            Object.keys(album.description.credits).forEach(key => {
              if (Array.isArray(album.description.credits[key])) {
                album.description.credits[key] = album.description.credits[key].filter(item => item && item.trim().length > 0);
              }
            });
          });
        }
        
        // Debug: Log the loaded data to check if it's already corrupted
        console.log('Loaded albumsData (after normalization):', albumsData);
        if (albumsData.albums && albumsData.albums.length > 0) {
          albumsData.albums.forEach((album, idx) => {
            if (album.description?.credits?.artists && album.description.credits.artists.length > 0) {
              const firstArtist = album.description.credits.artists[0];
              if (firstArtist && firstArtist.length < 5) {
                console.warn(`Album ${idx} has suspiciously short first artist credit: "${firstArtist}"`);
              }
            }
          });
        }
        
        renderAlbums();
        renderAbout();
        renderPressItems();
        showStatus('Content loaded successfully', 'success');
      } catch (error) {
        showStatus('Error loading content: ' + error.message, 'error');
        console.error(error);
      }
    }
    
    function createNewAlbum() {
      if (!albumsData) {
        albumsData = { albums: [] };
      }
      
      // Generate a new ID in format "orth001", "orth002", etc.
      // Find the highest number from existing "orth" IDs
      const orthIds = albumsData.albums
        .map(a => {
          if (typeof a.id === 'string' && a.id.toLowerCase().startsWith('orth')) {
            const numPart = parseInt(a.id.toLowerCase().replace('orth', ''));
            return isNaN(numPart) ? 0 : numPart;
          }
          return 0;
        })
        .filter(n => n > 0);
      
      const maxOrthNum = orthIds.length > 0 ? Math.max(...orthIds) : 0;
      const newIdNum = maxOrthNum + 1;
      const newId = `orth${newIdNum.toString().padStart(3, '0')}`;
      
      const newAlbum = {
        id: newId,
        urlPath: '',
        artist: '',
        title: '',
        releaseDate: new Date().toISOString().split('T')[0],
        cover: '',
        description: {
          paragraphs: [],
          credits: {
            artists: [],
            production: [],
            coverArt: [],
            additional: []
          }
        }
      };
      
      albumsData.albums.push(newAlbum);
      renderAlbums();
      showStatus('New album created. Fill in the details and save.', 'info');
      
      // Scroll to the new album
      setTimeout(() => {
        const items = document.querySelectorAll('.item-item');
        if (items.length > 0) {
          items[items.length - 1].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
      }, 100);
    }
    
    function deleteAlbum(index) {
      if (confirm('Are you sure you want to delete this album?')) {
        albumsData.albums.splice(index, 1);
        renderAlbums();
        showStatus('Album deleted. Remember to save changes.', 'info');
      }
    }
    
    function moveAlbum(index, direction) {
      if (direction === 'up' && index > 0) {
        [albumsData.albums[index], albumsData.albums[index - 1]] = 
          [albumsData.albums[index - 1], albumsData.albums[index]];
        renderAlbums();
      } else if (direction === 'down' && index < albumsData.albums.length - 1) {
        [albumsData.albums[index], albumsData.albums[index + 1]] = 
          [albumsData.albums[index + 1], albumsData.albums[index]];
        renderAlbums();
      }
    }
    
    function applySort() {
      if (!albumsData || !albumsData.albums || albumsData.albums.length === 0) {
        showStatus('No albums to sort', 'info');
        return;
      }
      
      // Show warning
      const warningDiv = document.getElementById('sort-warning');
      warningDiv.classList.add('show');
      
      // Confirm before sorting
      if (!confirm('Are you sure you want to reorder albums? The current manual ordering will be lost. You can undo this by refreshing the page before saving.')) {
        warningDiv.classList.remove('show');
        return;
      }
      
      const sortField = document.getElementById('sort-field').value;
      const sortOrder = document.getElementById('sort-order').value;
      
      // Save all current values before sorting
      saveAllCurrentValues();
      
      // Create a copy of albums for sorting
      const sortedAlbums = [...albumsData.albums];
      
      // Sort based on selected field
      sortedAlbums.sort((a, b) => {
        let aValue, bValue;
        
        switch (sortField) {
          case 'id':
            // Compare string IDs (e.g., "orth001", "room001")
            aValue = (a.id || '').toLowerCase();
            bValue = (b.id || '').toLowerCase();
            break;
          case 'releaseDate':
            // Parse dates for proper comparison (YYYY-MM-DD format)
            aValue = a.releaseDate ? new Date(a.releaseDate).getTime() : 0;
            bValue = b.releaseDate ? new Date(b.releaseDate).getTime() : 0;
            break;
          case 'artist':
            aValue = (a.artist || '').toLowerCase();
            bValue = (b.artist || '').toLowerCase();
            break;
          case 'title':
            aValue = (a.title || '').toLowerCase();
            bValue = (b.title || '').toLowerCase();
            break;
          default:
            return 0;
        }
        
        // Compare values
        let comparison = 0;
        if (aValue < bValue) {
          comparison = -1;
        } else if (aValue > bValue) {
          comparison = 1;
        }
        
        // Apply sort order
        return sortOrder === 'asc' ? comparison : -comparison;
      });
      
      // Update albumsData with sorted array
      albumsData.albums = sortedAlbums;
      
      // Re-render albums
      renderAlbums();
      
      // Show success message
      showStatus(`Albums sorted by ${sortField} (${sortOrder === 'asc' ? 'ascending' : 'descending'}). Remember to save your changes.`, 'success');
      
      // Keep warning visible
      setTimeout(() => {
        warningDiv.classList.remove('show');
      }, 10000); // Hide warning after 10 seconds
    }
    
    function applyPressSort() {
      if (!pressData || !pressData.items || pressData.items.length === 0) {
        showStatus('No press items to sort', 'info');
        return;
      }
      
      // Show warning
      const warningDiv = document.getElementById('press-sort-warning');
      warningDiv.classList.add('show');
      
      // Confirm before sorting
      if (!confirm('Are you sure you want to reorder press items? The current manual ordering will be lost. You can undo this by refreshing the page before saving.')) {
        warningDiv.classList.remove('show');
        return;
      }
      
      const sortField = document.getElementById('press-sort-field').value;
      const sortOrder = document.getElementById('press-sort-order').value;
      
      // Save all current values before sorting
      saveAllCurrentValues();
      
      // Create a copy of press items for sorting
      const sortedItems = [...pressData.items];
      
      // Sort based on selected field
      sortedItems.sort((a, b) => {
        let aValue, bValue;
        
        switch (sortField) {
          case 'id':
            // Compare string IDs
            aValue = (a.id || '').toLowerCase();
            bValue = (b.id || '').toLowerCase();
            break;
          case 'date':
            // Parse dates for proper comparison (YYYY-MM-DD format)
            aValue = a.date ? new Date(a.date).getTime() : 0;
            bValue = b.date ? new Date(b.date).getTime() : 0;
            break;
          case 'title':
            aValue = (a.title || '').toLowerCase();
            bValue = (b.title || '').toLowerCase();
            break;
          default:
            return 0;
        }
        
        // Compare values
        let comparison = 0;
        if (aValue < bValue) {
          comparison = -1;
        } else if (aValue > bValue) {
          comparison = 1;
        }
        
        // Apply sort order
        return sortOrder === 'asc' ? comparison : -comparison;
      });
      
      // Update pressData with sorted array
      pressData.items = sortedItems;
      
      // Re-render press items
      renderPressItems();
      
      // Show success message
      showStatus(`Press items sorted by ${sortField} (${sortOrder === 'asc' ? 'ascending' : 'descending'}). Remember to save your changes.`, 'success');
      
      // Keep warning visible
      setTimeout(() => {
        warningDiv.classList.remove('show');
      }, 10000); // Hide warning after 10 seconds
    }
    
    function renderAlbums() {
      const container = document.getElementById('albums-list');
      container.innerHTML = '';
      
      if (!albumsData || !albumsData.albums || albumsData.albums.length === 0) {
        container.innerHTML = '<p style="color: #666; padding: 20px;">No albums yet. Click "Create New Album" to get started.</p>';
        return;
      }
      
      albumsData.albums.forEach((album, index) => {
        const albumDiv = document.createElement('div');
        albumDiv.className = 'item-item';
        albumDiv.setAttribute('data-index', index);
        
        const title = album.artist && album.title 
          ? `${album.artist} - ${album.title}`
          : 'New Album (untitled)';
        
        albumDiv.innerHTML = `
          <div class="item-header">
            <h3>${escapeHtml(title)}</h3>
            <div class="item-controls">
              <button class="btn btn-small" onclick="moveAlbum(${index}, 'up')" ${index === 0 ? 'disabled' : ''}>↑</button>
              <button class="btn btn-small" onclick="moveAlbum(${index}, 'down')" ${index === albumsData.albums.length - 1 ? 'disabled' : ''}>↓</button>
              <button class="btn btn-small btn-danger" onclick="deleteAlbum(${index})">Delete</button>
            </div>
          </div>
          <div class="meta">
            Release Date: ${album.releaseDate || 'Not set'} | 
            ${album.urlPath ? `<a href="${BASE_URL}/album/${escapeHtml(album.urlPath)}" target="_blank" style="color: #0c5460; text-decoration: underline;">${BASE_URL}/album/${escapeHtml(album.urlPath)}</a>` : 'URL: Not set'}
          </div>
          
          <div class="form-row">
            <div class="form-group">
              <label>ID <span style="color: #666; font-size: 12px;">(required, e.g., orth001, room001)</span></label>
              <input type="text" data-field="id" data-index="${index}" value="${album.id || ''}" required pattern="[a-z]{3,4}[0-9]{3}" placeholder="orth001" onchange="validateAlbumId(${index}, this)" onblur="validateAlbumId(${index}, this)" style="${!album.id ? 'border-color: #dc3545;' : ''}">
              <div id="id-error-${index}" style="color: #dc3545; font-size: 12px; margin-top: 5px; display: none;"></div>
            </div>
            <div class="form-group">
              <label>Artist <span style="color: #dc3545;">*</span></label>
              <input type="text" data-field="artist" data-index="${index}" value="${escapeHtml(album.artist || '')}" required style="${!album.artist ? 'border-color: #dc3545;' : ''}">
            </div>
          </div>
          
          <div class="form-row">
            <div class="form-group">
              <label>Title <span style="color: #dc3545;">*</span></label>
              <input type="text" data-field="title" data-index="${index}" value="${escapeHtml(album.title || '')}" required style="${!album.title ? 'border-color: #dc3545;' : ''}">
            </div>
            <div class="form-group"></div>
          </div>
          
          <div class="form-row">
            <div class="form-group">
              <label>URL Path <span style="color: #dc3545;">*</span> <span style="color: #666; font-size: 12px;">(used in album URL)</span></label>
              <input type="text" data-field="urlPath" data-index="${index}" value="${escapeHtml(album.urlPath || '')}" placeholder="e.g., do-i-care" required pattern="[a-z0-9-]+" onchange="updateAlbumUrlPreview(${index})" style="${!album.urlPath ? 'border-color: #dc3545;' : ''}">
              <div id="url-preview-${index}" style="margin-top: 5px; font-size: 12px; color: #666;">
                ${album.urlPath ? `Full URL: <a href="${BASE_URL}/album/${escapeHtml(album.urlPath)}" target="_blank" style="color: #0c5460; text-decoration: underline;">${BASE_URL}/album/${escapeHtml(album.urlPath)}</a>` : 'Enter a URL path to see the full album URL'}
              </div>
            </div>
            <div class="form-group">
              <label>Release Date <span style="color: #dc3545;">*</span></label>
              <input type="date" data-field="releaseDate" data-index="${index}" value="${album.releaseDate || ''}" required style="${!album.releaseDate ? 'border-color: #dc3545;' : ''}">
            </div>
          </div>
          
          <div class="form-row">
            <div class="form-group">
              <label>Cover Image <span style="color: #dc3545;">*</span></label>
              <div style="display: flex; gap: 10px; align-items: flex-start;">
                <input type="text" data-field="cover" data-index="${index}" value="${escapeHtml(album.cover || '')}" required style="flex: 1; ${!album.cover ? 'border-color: #dc3545;' : ''}">
                <input type="file" accept="image/*" data-index="${index}" id="cover-upload-${index}" style="display: none;" onchange="handleImageUpload(${index}, this)">
                <button type="button" class="btn btn-small" onclick="document.getElementById('cover-upload-${index}').click()">Upload</button>
              </div>
              <div id="cover-preview-${index}" style="margin-top: 10px;">
                ${album.cover ? `<img src="/orthodox-website/${album.cover}" alt="Cover preview" style="max-width: 200px; max-height: 200px; border: 1px solid #ddd; border-radius: 4px;" onerror="this.style.display='none'">` : ''}
              </div>
              <div id="cover-upload-status-${index}" style="margin-top: 5px; font-size: 12px;"></div>
            </div>
            <div class="form-group">
              <label>Bandcamp Embed ID</label>
              <input type="number" data-field="bandcampEmbedId" data-index="${index}" value="${album.bandcampEmbedId || ''}">
            </div>
          </div>
          
          <div class="form-group">
            <label>Description Paragraphs</label>
            <div id="paragraphs-${index}"></div>
            <button type="button" class="btn btn-small" onclick="addParagraph(${index})">Add Paragraph</button>
          </div>
          
          <div class="form-group">
            <label>Credits - Artists</label>
            <div id="artists-${index}"></div>
            <button type="button" class="btn btn-small" onclick="addCredit(${index}, 'artists')">Add Artist Credit</button>
          </div>
          
          <div class="form-group">
            <label>Credits - Production</label>
            <div id="production-${index}"></div>
            <button type="button" class="btn btn-small" onclick="addCredit(${index}, 'production')">Add Production Credit</button>
          </div>
          
          <div class="form-group">
            <label>Credits - Cover Art</label>
            <div id="coverArt-${index}"></div>
            <button type="button" class="btn btn-small" onclick="addCredit(${index}, 'coverArt')">Add Cover Art Credit</button>
          </div>
          
          <div class="form-group">
            <label>Credits - Additional</label>
            <div id="additional-${index}"></div>
            <button type="button" class="btn btn-small" onclick="addCredit(${index}, 'additional')">Add Additional Credit</button>
          </div>
        `;
        
        container.appendChild(albumDiv);
        
        // Render paragraphs
        renderList(`paragraphs-${index}`, album.description?.paragraphs || [], index, 'paragraphs');
        
        // Render credits
        if (!album.description) album.description = { paragraphs: [], credits: {} };
        if (!album.description.credits) album.description.credits = {};
        
        renderList(`artists-${index}`, album.description.credits?.artists || [], index, 'credits.artists');
        renderList(`production-${index}`, album.description.credits?.production || [], index, 'credits.production');
        renderList(`coverArt-${index}`, album.description.credits?.coverArt || [], index, 'credits.coverArt');
        renderList(`additional-${index}`, album.description.credits?.additional || [], index, 'credits.additional');
      });
      
      // Attach input listeners - only for top-level fields, not nested ones like credits
      container.querySelectorAll('input[data-field][data-index], textarea[data-field][data-index]').forEach(input => {
        const field = input.dataset.field;
        // Skip nested fields (like credits.artists) - those are handled by updateList
        if (field && !field.includes('.')) {
          input.addEventListener('change', updateAlbum);
        }
      });
    }
    
    function saveListValues(containerId, albumIndex, fieldPath) {
      const container = document.getElementById(containerId);
      if (!container) {
        // Container doesn't exist yet, nothing to save
        return;
      }
      
      // Save current input values before re-rendering
      // Read all inputs - use a more specific selector to ensure we get all inputs
      // Try multiple selectors to be thorough
      let inputs = Array.from(container.querySelectorAll('input[type="text"]'));
      
      // If no inputs found with that selector, try a broader search
      if (inputs.length === 0) {
        inputs = Array.from(container.querySelectorAll('input'));
      }
      
      if (inputs.length === 0) {
        // No inputs found - this could mean:
        // 1. The list is actually empty (user deleted all items)
        // 2. The container is being re-rendered and is temporarily empty
        // Only set to empty array if the container is actually empty (not just being re-rendered)
        // We'll let renderList handle the empty case, so we don't overwrite data here
        return;
      }
      
      // Filter and validate inputs - ensure they have data-item attribute
      // Note: data-item="0" is valid, so we check for undefined/null/empty string specifically
      const validInputs = inputs.filter(input => {
        const itemIndex = input.getAttribute('data-item');
        // Check if data-item exists (even if it's "0")
        return itemIndex !== null;
      });
      
      if (validInputs.length === 0) {
        console.warn(`No valid inputs found in ${containerId} for saving ${fieldPath}`);
        // No valid inputs found, skip saving to avoid overwriting with empty array
        return;
      }
      
      // Sort inputs by their item index to ensure correct order
      validInputs.sort((a, b) => {
        const indexA = parseInt(a.getAttribute('data-item')) || 0;
        const indexB = parseInt(b.getAttribute('data-item')) || 0;
        return indexA - indexB;
      });
      
      // Verify we have consecutive indices (0, 1, 2, ...) - if not, log a warning
      const indices = validInputs.map(input => parseInt(input.getAttribute('data-item')) || 0);
      const expectedIndices = Array.from({ length: validInputs.length }, (_, i) => i);
      const hasGaps = !indices.every((idx, i) => idx === expectedIndices[i]);
      if (hasGaps) {
        console.warn(`Warning: Input indices have gaps in ${containerId}:`, indices);
      }
      
      // Build array from DOM values - preserve empty strings but ensure we get the full value
      const values = validInputs.map((input, idx) => {
        // Get the value directly from the input element's value property
        // This is the most reliable way to get the current value
        let val = input.value;
        
        // If value is null/undefined, use empty string
        if (val === null || val === undefined) {
          val = '';
        }
        
        // Convert to string to ensure we have a string value
        val = String(val);
        
        // Debug: Log detailed info for suspicious values (first item only, and only if very short)
        if (val.length > 0 && val.length < 5 && idx === 0) {
          console.warn(`Warning: First value in ${fieldPath} for album ${albumIndex} seems short: "${val}"`, {
            inputValue: input.value,
            inputValueLength: input.value?.length || 0,
            defaultValue: input.defaultValue,
            attributeValue: input.getAttribute('value'),
            maxLength: input.maxLength,
            dataItem: input.getAttribute('data-item')
          });
          
          // If we detect a suspiciously short value, also log all inputs to see what's happening
          console.log('All inputs in container:', Array.from(container.querySelectorAll('input[type="text"]')).map(inp => ({
            dataItem: inp.getAttribute('data-item'),
            value: inp.value,
            valueLength: inp.value?.length || 0
          })));
        }
        
        return val;
      });
      
      // Debug logging - log the actual values being saved with detailed info
      const currentDataValue = (() => {
        // Handle about-paragraphs separately
        if (fieldPath === 'about-paragraphs') {
          return aboutData?.paragraphs;
        }
        
        // Use the same path resolution logic as the save operation
        let debugPath = fieldPath;
        if (fieldPath === 'paragraphs') {
          debugPath = 'description.paragraphs';
        } else if (fieldPath.startsWith('credits.')) {
          debugPath = 'description.' + fieldPath;
        }
        
        const paths = debugPath.split('.');
        let target = albumsData.albums[albumIndex];
        if (!target) return undefined;
        
        for (let i = 0; i < paths.length - 1; i++) {
          if (paths[i] === 'description') {
            target = target?.description;
          } else if (paths[i] === 'credits') {
            target = target?.credits;
          } else {
            target = target?.[paths[i]];
          }
          if (!target) return undefined;
        }
        return target?.[paths[paths.length - 1]];
      })();
      
      console.log(`Saving ${fieldPath} for album ${albumIndex}:`, {
        inputCount: validInputs.length,
        values: values,
        firstValueLength: values[0]?.length || 0,
        firstValue: values[0],
        // Compare with what's in albumsData
        currentDataValue: currentDataValue,
        dataMatches: JSON.stringify(currentDataValue) === JSON.stringify(values)
      });
      
      // Handle about-paragraphs separately (albumIndex is null)
      if (fieldPath === 'about-paragraphs') {
        if (!aboutData) {
          aboutData = { paragraphs: [] };
        }
        aboutData.paragraphs = values;
        return;
      }
      
      // Handle special case for 'paragraphs' and 'credits.*' field paths
      let actualPath = fieldPath;
      if (fieldPath === 'paragraphs') {
        actualPath = 'description.paragraphs';
      } else if (fieldPath.startsWith('credits.')) {
        // Credits are nested under description, so prepend 'description.'
        actualPath = 'description.' + fieldPath;
      }
      
      const paths = actualPath.split('.');
      let target = albumsData.albums[albumIndex];
      
      if (!target) {
        console.error(`Album at index ${albumIndex} not found`);
        return;
      }
      
      // Ensure description exists
      if (paths[0] === 'description' || paths.includes('description')) {
        if (!target.description) {
          target.description = { paragraphs: [], credits: {} };
        }
      }
      
      // Navigate through the path
      for (let i = 0; i < paths.length - 1; i++) {
        if (paths[i] === 'description') {
          target = target.description;
          if (!target) {
            target = { paragraphs: [], credits: {} };
            albumsData.albums[albumIndex].description = target;
          }
        } else if (paths[i] === 'credits') {
          // Credits are nested under description, ensure credits object exists
          if (!target.credits) {
            target.credits = {};
          }
          target = target.credits;
        } else {
          if (!target[paths[i]]) {
            target[paths[i]] = {};
          }
          target = target[paths[i]];
        }
      }
      
      // Replace the entire array with values from DOM
      const finalKey = paths[paths.length - 1];
      target[finalKey] = values;
    }
    
    function renderList(containerId, items, albumIndex, fieldPath) {
      const container = document.getElementById(containerId);
      if (!container) return;
      
      // Save current values before clearing
      saveListValues(containerId, albumIndex, fieldPath);
      
      renderListWithoutSaving(containerId, items, albumIndex, fieldPath);
    }
    
    function renderListWithoutSaving(containerId, items, albumIndex, fieldPath) {
      const container = document.getElementById(containerId);
      if (!container) return;
      
      container.innerHTML = '';
      
      items.forEach((item, itemIndex) => {
        const div = document.createElement('div');
        div.className = 'list-item';
        
        // Ensure item is a string and not null/undefined
        const itemValue = (item !== null && item !== undefined) ? String(item) : '';
        
        // Debug: Log if we're rendering a suspiciously short value
        if (itemValue.length > 0 && itemValue.length < 5 && itemIndex === 0 && fieldPath.includes('credits')) {
          console.warn(`Rendering short value for ${fieldPath}[${itemIndex}]: "${itemValue}"`, {
            originalItem: item,
            itemType: typeof item,
            itemLength: itemValue.length,
            albumIndex,
            fieldPath
          });
        }
        
        // Create input element properly to avoid HTML attribute issues
        const input = document.createElement('input');
        input.type = 'text';
        input.setAttribute('data-album', albumIndex !== null ? albumIndex : '');
        input.setAttribute('data-field', fieldPath);
        input.setAttribute('data-item', itemIndex);
        input.value = itemValue; // Set value directly, not via HTML attribute
        
        // Verify the value was set correctly
        if (input.value !== itemValue) {
          console.error(`Value mismatch when setting input: expected "${itemValue}", got "${input.value}"`);
          input.value = itemValue; // Force set again
        }
        
        input.onchange = function() { updateList(this); };
        
        // Create remove button
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'btn btn-small btn-danger';
        removeBtn.textContent = 'Remove';
        if (fieldPath === 'about-paragraphs') {
          removeBtn.onclick = function() { removeAboutParagraph(itemIndex); };
        } else {
          removeBtn.onclick = function() { removeListItem(albumIndex, fieldPath, itemIndex); };
        }
        
        div.appendChild(input);
        div.appendChild(removeBtn);
        container.appendChild(div);
      });
    }
    
    function renderAbout() {
      if (!aboutData) {
        aboutData = { paragraphs: [] };
      }
      
      if (!aboutData.paragraphs) {
        aboutData.paragraphs = [];
      }
      
      renderList('about-paragraphs', aboutData.paragraphs, null, 'about-paragraphs');
    }
    
    function addAboutParagraph() {
      if (!aboutData) {
        aboutData = { paragraphs: [] };
      }
      
      if (!aboutData.paragraphs) {
        aboutData.paragraphs = [];
      }
      
      // Get current values from DOM before modifying
      const container = document.getElementById('about-paragraphs');
      if (container) {
        const inputs = Array.from(container.querySelectorAll('input[type="text"]'));
        // Filter to only include inputs with valid data-item attribute (same logic as saveListValues)
        const validInputs = inputs.filter(input => {
          const itemIndex = input.getAttribute('data-item');
          return itemIndex !== null;
        });
        // Sort by data-item index to ensure correct order
        validInputs.sort((a, b) => {
          const indexA = parseInt(a.getAttribute('data-item')) || 0;
          const indexB = parseInt(b.getAttribute('data-item')) || 0;
          return indexA - indexB;
        });
        const currentValues = validInputs.map(input => {
          const val = input.value;
          return (val !== null && val !== undefined) ? String(val) : '';
        });
        
        // Update the data structure with current DOM values
        aboutData.paragraphs = currentValues;
      }
      
      // Add new empty paragraph
      aboutData.paragraphs.push('');
      
      // Re-render the list - skip saving since we've already synced the DOM values to the data structure
      renderListWithoutSaving('about-paragraphs', aboutData.paragraphs, null, 'about-paragraphs');
    }
    
    function removeAboutParagraph(itemIndex) {
      // Save current values before removing
      saveListValues('about-paragraphs', null, 'about-paragraphs');
      
      if (aboutData && aboutData.paragraphs) {
        aboutData.paragraphs.splice(itemIndex, 1);
        // Use renderListWithoutSaving since we've already saved and removed the item from data structure
        renderListWithoutSaving('about-paragraphs', aboutData.paragraphs, null, 'about-paragraphs');
      }
    }
    
    function addParagraph(albumIndex) {
      if (!albumsData.albums[albumIndex].description) {
        albumsData.albums[albumIndex].description = { paragraphs: [], credits: {} };
      }
      if (!albumsData.albums[albumIndex].description.paragraphs) {
        albumsData.albums[albumIndex].description.paragraphs = [];
      }
      
      // Get current values from DOM before modifying
      const container = document.getElementById(`paragraphs-${albumIndex}`);
      if (container) {
        const inputs = Array.from(container.querySelectorAll('input[type="text"]'));
        // Filter to only include inputs with valid data-item attribute (same logic as saveListValues)
        const validInputs = inputs.filter(input => {
          const itemIndex = input.getAttribute('data-item');
          return itemIndex !== null;
        });
        // Sort by data-item index to ensure correct order
        validInputs.sort((a, b) => {
          const indexA = parseInt(a.getAttribute('data-item')) || 0;
          const indexB = parseInt(b.getAttribute('data-item')) || 0;
          return indexA - indexB;
        });
        const currentValues = validInputs.map(input => {
          const val = input.value;
          return (val !== null && val !== undefined) ? String(val) : '';
        });
        
        // Update the data structure with current DOM values
        albumsData.albums[albumIndex].description.paragraphs = currentValues;
      }
      
      // Add new empty paragraph
      albumsData.albums[albumIndex].description.paragraphs.push('');
      
      // Re-render the list - skip saving since we've already synced the DOM values to the data structure
      renderListWithoutSaving(`paragraphs-${albumIndex}`, albumsData.albums[albumIndex].description.paragraphs, albumIndex, 'paragraphs');
    }
    
    function addCredit(albumIndex, creditType) {
      if (!albumsData.albums[albumIndex].description) {
        albumsData.albums[albumIndex].description = { paragraphs: [], credits: {} };
      }
      if (!albumsData.albums[albumIndex].description.credits) {
        albumsData.albums[albumIndex].description.credits = {};
      }
      if (!albumsData.albums[albumIndex].description.credits[creditType]) {
        albumsData.albums[albumIndex].description.credits[creditType] = [];
      }
      
      // Get current values from DOM before modifying - this ensures we capture any unsaved edits
      const container = document.getElementById(`${creditType}-${albumIndex}`);
      let currentValues = [];
      if (container) {
        const inputs = Array.from(container.querySelectorAll('input[type="text"]'));
        // Filter to only include inputs with valid data-item attribute (same logic as saveListValues)
        const validInputs = inputs.filter(input => {
          const itemIndex = input.getAttribute('data-item');
          // Check if data-item exists (even if it's "0")
          return itemIndex !== null;
        });
        // Sort by data-item index to ensure correct order - use getAttribute to handle "0" correctly
        validInputs.sort((a, b) => {
          const indexA = parseInt(a.getAttribute('data-item')) || 0;
          const indexB = parseInt(b.getAttribute('data-item')) || 0;
          return indexA - indexB;
        });
        currentValues = validInputs.map(input => {
          const val = input.value;
          return (val !== null && val !== undefined) ? String(val) : '';
        });
        
        // Debug: Log if we're reading suspicious values
        if (currentValues.length > 0 && currentValues[0] && currentValues[0].length < 5) {
          console.warn(`addCredit: Reading short first value for ${creditType}: "${currentValues[0]}"`, {
            allValues: currentValues,
            inputCount: inputs.length
          });
        }
      } else {
        // If container doesn't exist, use existing values from data
        currentValues = albumsData.albums[albumIndex].description.credits[creditType] || [];
      }
      
      // Update the data structure with current DOM values
      albumsData.albums[albumIndex].description.credits[creditType] = currentValues;
      
      // Add new empty credit
      albumsData.albums[albumIndex].description.credits[creditType].push('');
      
      // Re-render the list - skip saving since we've already synced the DOM values to the data structure
      // and added the new credit, so we don't want saveListValues to overwrite with stale DOM values
      renderListWithoutSaving(`${creditType}-${albumIndex}`, albumsData.albums[albumIndex].description.credits[creditType], albumIndex, `credits.${creditType}`);
    }
    
    function removeListItem(albumIndex, fieldPath, itemIndex) {
      // Determine the container ID based on field path
      const lastPath = fieldPath.split('.').pop();
      const containerId = `${lastPath}-${albumIndex}`;
      
      // Save current values before removing
      saveListValues(containerId, albumIndex, fieldPath);
      
      const paths = fieldPath.split('.');
      let target = albumsData.albums[albumIndex];
      
      for (let i = 0; i < paths.length - 1; i++) {
        if (paths[i] === 'description') {
          target = target.description;
        } else if (paths[i] === 'credits') {
          if (!target.credits) return;
          target = target.credits;
        } else {
          if (!target[paths[i]]) return;
          target = target[paths[i]];
        }
      }
      
      if (target[paths[paths.length - 1]]) {
        target[paths[paths.length - 1]].splice(itemIndex, 1);
        // Use renderListWithoutSaving since we've already saved and removed the item from data structure
        renderListWithoutSaving(containerId, target[paths[paths.length - 1]], albumIndex, fieldPath);
      }
    }
    
    function updateAlbum(event) {
      const field = event.target.dataset.field;
      const index = parseInt(event.target.dataset.index);
      
      // Safety check
      if (!field || index === undefined || index === null || !albumsData.albums[index]) {
        console.error('Invalid updateAlbum call:', { field, index, album: albumsData.albums[index] });
        return;
      }
      
      // Skip nested fields (like credits.artists) - those should use updateList
      if (field.includes('.')) {
        console.warn('updateAlbum called for nested field, should use updateList:', field);
        return;
      }
      
      // Skip ID field - it's handled by validateAlbumId
      if (field === 'id') {
        return;
      }
      
      const value = event.target.type === 'number' ? (event.target.value ? parseInt(event.target.value) : undefined) : event.target.value;
      
      albumsData.albums[index][field] = value;
      
      // Update URL preview if urlPath changed
      if (field === 'urlPath') {
        updateAlbumUrlPreview(index);
      }
    }
    
    function updateAlbumUrlPreview(index) {
      const urlPath = albumsData.albums[index].urlPath || '';
      const previewDiv = document.getElementById(`url-preview-${index}`);
      if (previewDiv) {
        if (urlPath) {
          const fullUrl = `${BASE_URL}/album/${escapeHtml(urlPath)}`;
          previewDiv.innerHTML = `Full URL: <a href="${fullUrl}" target="_blank" style="color: #0c5460; text-decoration: underline;">${fullUrl}</a>`;
          } else {
          previewDiv.innerHTML = 'Enter a URL path to see the full album URL';
        }
      }
      
      // Also update the meta line
      const albumDiv = document.querySelector(`.item-item[data-index="${index}"]`);
      if (albumDiv) {
        const metaDiv = albumDiv.querySelector('.meta');
        if (metaDiv) {
          const album = albumsData.albums[index];
          const releaseDate = album.releaseDate || 'Not set';
          const urlPart = urlPath 
            ? `<a href="${BASE_URL}/album/${escapeHtml(urlPath)}" target="_blank" style="color: #0c5460; text-decoration: underline;">${BASE_URL}/album/${escapeHtml(urlPath)}</a>`
            : 'URL: Not set';
          metaDiv.innerHTML = `Release Date: ${releaseDate} | ${urlPart}`;
        }
      }
    }
    
    window.updateAlbumUrlPreview = updateAlbumUrlPreview;
    
    window.updateList = function(input) {
      // Use getAttribute to handle "0" correctly
      const albumIndexAttr = input.getAttribute('data-album');
      const albumIndex = albumIndexAttr !== null && albumIndexAttr !== '' ? parseInt(albumIndexAttr) : null;
      const fieldPath = input.getAttribute('data-field');
      const itemIndex = parseInt(input.getAttribute('data-item')) || 0;
      const value = input.value || '';
      
      // Handle about page paragraphs
      if (fieldPath === 'about-paragraphs') {
        if (!aboutData) {
          aboutData = { paragraphs: [] };
        }
        if (!aboutData.paragraphs) {
          aboutData.paragraphs = [];
        }
        while (aboutData.paragraphs.length <= itemIndex) {
          aboutData.paragraphs.push('');
        }
        aboutData.paragraphs[itemIndex] = value;
        return;
      }
      
      // Debug: Log if we're updating with a suspiciously short value
      if (value.length > 0 && value.length < 5 && itemIndex === 0 && fieldPath && fieldPath.includes('credits')) {
        console.warn(`updateList: Updating with short value for ${fieldPath}[${itemIndex}]: "${value}"`, {
          inputValue: input.value,
          inputValueLength: input.value?.length || 0,
          albumIndex,
          fieldPath,
          itemIndex
        });
      }
      
      // Skip if albumIndex is null
      if (albumIndex === null || albumIndex === undefined) {
        return;
      }
      
      const paths = fieldPath.split('.');
      let target = albumsData.albums[albumIndex];
      
      if (!target.description) target.description = { paragraphs: [], credits: {} };
      
      for (let i = 0; i < paths.length - 1; i++) {
        if (paths[i] === 'description') {
          target = target.description;
          if (!target) {
            target = { paragraphs: [], credits: {} };
            albumsData.albums[albumIndex].description = target;
          }
        } else if (paths[i] === 'credits') {
          if (!target.credits) target.credits = {};
          target = target.credits;
        } else {
          if (!target[paths[i]]) {
            target[paths[i]] = {};
          }
          target = target[paths[i]];
        }
      }
      
      const finalKey = paths[paths.length - 1];
      if (!target[finalKey]) {
        target[finalKey] = [];
      }
      
      // Ensure array is long enough before setting value
      const array = target[finalKey];
      while (array.length <= itemIndex) {
        array.push('');
      }
      
      array[itemIndex] = value;
    };
    
    window.removeListItem = removeListItem;
    window.addParagraph = addParagraph;
    window.addAboutParagraph = addAboutParagraph;
    window.addCredit = addCredit;
    window.deleteAlbum = deleteAlbum;
    window.moveAlbum = moveAlbum;
    
    async function handleImageUpload(albumIndex, fileInput) {
      const file = fileInput.files[0];
      if (!file) return;
      
      // Validate file type
      if (!file.type.startsWith('image/')) {
        showStatus('Please select an image file', 'error');
        return;
      }
      
      // Validate file size (max 10MB)
      if (file.size > 10 * 1024 * 1024) {
        showStatus('Image file is too large. Maximum size is 10MB.', 'error');
        return;
      }
      
      const statusDiv = document.getElementById(`cover-upload-status-${albumIndex}`);
      statusDiv.textContent = 'Uploading...';
      statusDiv.style.color = '#0c5460';
      
      try {
        // Generate filename from album URL path or use sanitized original filename
        let filename;
        const album = albumsData.albums[albumIndex];
        if (album.urlPath) {
          const ext = file.name.split('.').pop();
          filename = `${album.urlPath.replace(/[^a-z0-9-]/gi, '_').toLowerCase()}.${ext}`;
        } else {
          // Sanitize filename
          filename = file.name.replace(/[^a-z0-9.-]/gi, '_').toLowerCase();
        }
        
        const filePath = `public/${filename}`;
        
        // Read file as base64
        const reader = new FileReader();
        reader.onload = async function(e) {
          try {
            const base64Content = e.target.result.split(',')[1]; // Remove data:image/...;base64, prefix
            
            // Check if file already exists
            let sha = null;
            try {
              const existingFile = await fetch(`${PROXY_URL}/repos/${REPO_OWNER}/${REPO_NAME}/contents/${filePath}`, {
                headers: {
                  'Authorization': `token ${token}`,
                  'Accept': 'application/vnd.github.v3+json'
                }
              });
              
              if (existingFile.ok) {
                const existing = await existingFile.json();
                sha = existing.sha;
                    }
                  } catch (e) {
              // File doesn't exist, that's fine
            }
            
            // Upload file to GitHub
            const uploadResponse = await fetch(`${PROXY_URL}/repos/${REPO_OWNER}/${REPO_NAME}/contents/${filePath}`, {
              method: 'PUT',
              headers: {
                'Authorization': `token ${token}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                message: `Upload cover image: ${filename}`,
                content: base64Content,
                sha: sha,
                branch: BRANCH
              })
            });
            
            if (!uploadResponse.ok) {
              const error = await uploadResponse.json().catch(() => ({}));
              throw new Error(error.message || 'Failed to upload image');
            }
            
            // Update cover field
            albumsData.albums[albumIndex].cover = filename;
            const coverInput = document.querySelector(`input[data-field="cover"][data-index="${albumIndex}"]`);
            if (coverInput) {
              coverInput.value = filename;
            }
            
            // Update preview
            const previewDiv = document.getElementById(`cover-preview-${albumIndex}`);
            if (previewDiv) {
              const existingImg = previewDiv.querySelector('img');
              if (existingImg) {
                existingImg.src = `/orthodox-website/${filename}`;
                existingImg.style.display = 'block';
              } else {
                const img = document.createElement('img');
                img.src = `/orthodox-website/${filename}`;
                img.alt = 'Cover preview';
                img.style.cssText = 'max-width: 200px; max-height: 200px; border: 1px solid #ddd; border-radius: 4px;';
                img.onerror = function() { this.style.display = 'none'; };
                previewDiv.appendChild(img);
              }
            }
            
            statusDiv.textContent = 'Uploaded successfully!';
            statusDiv.style.color = '#155724';
            showStatus('Image uploaded successfully!', 'success');
            
            // Reset file input
            fileInput.value = '';
          } catch (error) {
            statusDiv.textContent = 'Upload failed: ' + error.message;
            statusDiv.style.color = '#721c24';
            showStatus('Error uploading image: ' + error.message, 'error');
            console.error(error);
          }
        };
        
        reader.readAsDataURL(file);
      } catch (error) {
        statusDiv.textContent = 'Error: ' + error.message;
        statusDiv.style.color = '#721c24';
        showStatus('Error uploading image: ' + error.message, 'error');
        console.error(error);
      }
    }
    
    window.handleImageUpload = handleImageUpload;
    
    function saveAllCurrentValues() {
      // Save all regular input fields
      document.querySelectorAll('input[data-field][data-index], textarea[data-field][data-index]').forEach(input => {
        const field = input.dataset.field;
        const index = parseInt(input.dataset.index);
        const value = input.type === 'number' 
          ? (input.value ? parseInt(input.value) : undefined) 
          : input.value;
        
        if (field === 'id') {
          // ID is handled separately with validation
          return;
        }
        
        if (albumsData.albums[index]) {
          albumsData.albums[index][field] = value;
        }
      });
      
      // Save all list values (paragraphs and credits) - ensure we save in the correct order
      // CRITICAL: Save ALL list values from DOM before saving to ensure we capture any unsaved edits
      albumsData.albums.forEach((album, index) => {
        // Always try to save - saveListValues will check if container exists
        // This ensures we capture values even if user hasn't blurred inputs yet
        saveListValues(`paragraphs-${index}`, index, 'paragraphs');
        saveListValues(`artists-${index}`, index, 'credits.artists');
        saveListValues(`production-${index}`, index, 'credits.production');
        saveListValues(`coverArt-${index}`, index, 'credits.coverArt');
        saveListValues(`additional-${index}`, index, 'credits.additional');
      });
      
      // Save about page paragraphs
      saveListValues('about-paragraphs', null, 'about-paragraphs');
      
      // Save press item values
      if (pressData && pressData.items) {
        const pressContainer = document.getElementById('press-items-list');
        if (pressContainer) {
          pressContainer.querySelectorAll('input[data-field][data-index], textarea[data-field][data-index]').forEach(input => {
            const field = input.dataset.field;
            const index = parseInt(input.dataset.index);
            
            if (pressData.items[index]) {
              const value = input.type === 'date' 
                ? input.value 
                : (input.type === 'number' 
                  ? (input.value ? parseInt(input.value) : undefined) 
                  : input.value);
              
              // Skip ID field as it's handled by validatePressId
              if (field !== 'id') {
                pressData.items[index][field] = value;
              }
            }
          });
        }
      }
    }
    
    // Helper function to encode content to base64 with proper UTF-8 handling
    function encodeContent(content) {
      const encoder = new TextEncoder();
      const bytes = encoder.encode(content);
      const binaryString = String.fromCharCode(...bytes);
      return btoa(binaryString);
    }
    
    // Helper function to get the latest commit SHA
    async function getLatestCommitSha() {
      const refResponse = await fetch(`${PROXY_URL}/repos/${REPO_OWNER}/${REPO_NAME}/git/ref/heads/${BRANCH}`, {
        headers: {
          'Authorization': `token ${token}`,
          'Accept': 'application/vnd.github.v3+json'
        }
      });
      
      if (!refResponse.ok) {
        const error = await refResponse.json().catch(() => ({}));
        throw new Error(error.message || `Failed to get branch ref: ${refResponse.status}`);
      }
      
      const refData = await refResponse.json();
      return refData.object.sha;
    }
    
    // Helper function to create a single commit with multiple files using Git Data API
    async function createSingleCommit(files, commitMessage, retryCount = 0) {
      const maxRetries = 5; // Increased retries to handle GitHub Actions commits
      
      // Get the current commit SHA - fetch fresh each time
      const currentCommitSha = await getLatestCommitSha();
      
      // Get the commit object
      const commitResponse = await fetch(`${PROXY_URL}/repos/${REPO_OWNER}/${REPO_NAME}/git/commits/${currentCommitSha}`, {
        headers: {
          'Authorization': `token ${token}`,
          'Accept': 'application/vnd.github.v3+json'
        }
      });
      
      if (!commitResponse.ok) {
        const error = await commitResponse.json().catch(() => ({}));
        throw new Error(error.message || `Failed to get commit: ${commitResponse.status}`);
      }
      
      const commitData = await commitResponse.json();
      const baseTreeSha = commitData.tree.sha;
      
      // Create blobs for all files first
      const blobPromises = files.map(async (file) => {
        const encodedContent = encodeContent(file.content);
        const blobResponse = await fetch(`${PROXY_URL}/repos/${REPO_OWNER}/${REPO_NAME}/git/blobs`, {
          method: 'POST',
          headers: {
            'Authorization': `token ${token}`,
            'Accept': 'application/vnd.github.v3+json',
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            content: encodedContent,
            encoding: 'base64'
          })
        });
        
        if (!blobResponse.ok) {
          const error = await blobResponse.json().catch(() => ({}));
          throw new Error(error.message || `Failed to create blob for ${file.path}: ${blobResponse.status}`);
        }
        
        return await blobResponse.json();
      });
      
      const blobs = await Promise.all(blobPromises);
      
      // Build tree entries - use base_tree to preserve existing files, then add/update our files
      const treeEntries = files.map((file, index) => ({
        path: file.path,
        mode: '100644', // Regular file
        type: 'blob',
        sha: blobs[index].sha
      }));
      
      // Create new tree using base_tree to preserve all existing files
      const newTreeResponse = await fetch(`${PROXY_URL}/repos/${REPO_OWNER}/${REPO_NAME}/git/trees`, {
        method: 'POST',
        headers: {
          'Authorization': `token ${token}`,
          'Accept': 'application/vnd.github.v3+json',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          base_tree: baseTreeSha,
          tree: treeEntries
        })
      });
      
      if (!newTreeResponse.ok) {
        const error = await newTreeResponse.json().catch(() => ({}));
        throw new Error(error.message || `Failed to create tree: ${newTreeResponse.status}`);
      }
      
      const newTreeData = await newTreeResponse.json();
      
      // Fetch the latest commit SHA again right before creating the commit
      // This minimizes the window for race conditions
      const latestCommitSha = await getLatestCommitSha();
      
      // Create new commit
      const newCommitResponse = await fetch(`${PROXY_URL}/repos/${REPO_OWNER}/${REPO_NAME}/git/commits`, {
        method: 'POST',
        headers: {
          'Authorization': `token ${token}`,
          'Accept': 'application/vnd.github.v3+json',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          message: commitMessage,
          tree: newTreeData.sha,
          parents: [latestCommitSha]
        })
      });
      
      if (!newCommitResponse.ok) {
        const error = await newCommitResponse.json().catch(() => ({}));
        throw new Error(error.message || `Failed to create commit: ${newCommitResponse.status}`);
      }
      
      const newCommitData = await newCommitResponse.json();
      
      // Update branch reference - fetch latest SHA one more time right before update
      const finalCommitSha = await getLatestCommitSha();
      
      // If the branch moved, we need to retry
      if (finalCommitSha !== latestCommitSha) {
        if (retryCount < maxRetries) {
          // Wait longer before retrying to allow GitHub Actions to complete
          await new Promise(resolve => setTimeout(resolve, 1000 * (retryCount + 1))); // Increasing wait time
          return createSingleCommit(files, commitMessage, retryCount + 1);
        } else {
          throw new Error('Branch was updated multiple times (possibly by GitHub Actions). Please wait a moment and try again.');
        }
      }
      
      const updateRefResponse = await fetch(`${PROXY_URL}/repos/${REPO_OWNER}/${REPO_NAME}/git/refs/heads/${BRANCH}`, {
        method: 'PATCH',
        headers: {
          'Authorization': `token ${token}`,
          'Accept': 'application/vnd.github.v3+json',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          sha: newCommitData.sha,
          force: false // Ensure we don't force push
        })
      });
      
      if (!updateRefResponse.ok) {
        const error = await updateRefResponse.json().catch(() => ({}));
        
        // If it's a fast-forward error and we haven't retried too many times, retry
        if (error.message && (error.message.includes('fast forward') || error.message.includes('Update is not a fast forward')) && retryCount < maxRetries) {
          // Wait longer before retrying - GitHub Actions might be creating commits
          await new Promise(resolve => setTimeout(resolve, 2000 * (retryCount + 1))); // Increasing wait time
          return createSingleCommit(files, commitMessage, retryCount + 1);
        }
        
        throw new Error(error.message || `Failed to update branch: ${updateRefResponse.status}`);
      }
      
      return newCommitData;
    }
    
    document.getElementById('save-btn').addEventListener('click', async () => {
      try {
        // Debug: Log albumsData before saving to see if it's already corrupted
        console.log('albumsData before saveAllCurrentValues:', JSON.parse(JSON.stringify(albumsData)));
        
        // Save all current values from the DOM before saving
        saveAllCurrentValues();
        
        // Debug: Log albumsData after saving to see what changed
        console.log('albumsData after saveAllCurrentValues:', JSON.parse(JSON.stringify(albumsData)));
        
        // Validate all required fields
        const requiredFields = ['id', 'artist', 'title', 'urlPath', 'releaseDate', 'cover'];
        const missingFields = [];
        
        albumsData.albums.forEach((album, index) => {
          const missing = [];
          requiredFields.forEach(field => {
            const value = album[field];
            if (!value || (typeof value === 'string' && value.trim() === '')) {
              missing.push(field);
            }
          });
          if (missing.length > 0) {
            missingFields.push({ index, fields: missing });
          }
        });
        
        if (missingFields.length > 0) {
          const errorMsg = missingFields.map(({ index, fields }) => 
            `Album ${index + 1}: missing ${fields.join(', ')}`
          ).join('; ');
          showStatus(`Error: Missing required fields. ${errorMsg}. Please fill in all required fields (marked with *).`, 'error');
          return;
        }
        
        // Validate IDs are unique
        const ids = albumsData.albums.map(a => a.id ? a.id.toLowerCase().trim() : '').filter(id => id !== '');
        const duplicateIds = ids.filter((id, index) => ids.indexOf(id) !== index);
        if (duplicateIds.length > 0) {
          showStatus(`Error: Duplicate IDs found: ${duplicateIds.join(', ')}. Please ensure all IDs are unique.`, 'error');
          return;
        }
        
        // Validate URL paths are unique
        const urlPaths = albumsData.albums.map(a => a.urlPath ? a.urlPath.toLowerCase().trim() : '').filter(path => path !== '');
        const duplicatePaths = urlPaths.filter((path, index) => urlPaths.indexOf(path) !== index);
        if (duplicatePaths.length > 0) {
          showStatus(`Error: Duplicate URL paths found: ${duplicatePaths.join(', ')}. Please ensure all URL paths are unique.`, 'error');
          return;
        }
        
        const saveBtn = document.getElementById('save-btn');
        const originalText = saveBtn.textContent;
        saveBtn.disabled = true;
        saveBtn.textContent = 'Saving...';
        
        // Show toast notification
        const savingToast = showToast(
          'Saving Changes',
          'Uploading changes to GitHub...',
          'info',
          0 // Don't auto-close
        );
        
        // Prepare files to save
        const filesToSave = [];
        
        // Add albums file
        const albumsContent = JSON.stringify(albumsData, null, 2);
        filesToSave.push({
          path: ALBUMS_FILE_PATH,
          content: albumsContent
        });
        
        // Add about file if it exists
        if (aboutData) {
          const aboutContent = JSON.stringify(aboutData, null, 2);
          filesToSave.push({
            path: ABOUT_FILE_PATH,
            content: aboutContent
          });
        }
        
        // Add press file if it exists and validate required fields
        if (pressData && pressData.items) {
          // Validate required fields for press items
          const requiredPressFields = ['id', 'title', 'publication', 'date', 'link'];
          const missingPressFields = [];
          
          pressData.items.forEach((item, index) => {
            const missing = [];
            requiredPressFields.forEach(field => {
              const value = item[field];
              if (value === undefined || value === null || (typeof value === 'string' && value.trim() === '')) {
                missing.push(field);
              }
            });
            if (missing.length > 0) {
              missingPressFields.push({ index, fields: missing });
            }
          });
          
          if (missingPressFields.length > 0) {
            const errorMsg = missingPressFields.map(({ index, fields }) => 
              `Press Item ${index + 1}: missing ${fields.join(', ')}`
            ).join('; ');
            throw new Error(`Error: Missing required fields in press items. ${errorMsg}. Please fill in all required fields (marked with *).`);
          }
          
          // Validate IDs are unique
          const pressIds = pressData.items.map(item => item.id).filter(id => id !== undefined && id !== null);
          const duplicatePressIds = pressIds.filter((id, index) => pressIds.indexOf(id) !== index);
          if (duplicatePressIds.length > 0) {
            throw new Error(`Error: Duplicate press item IDs found: ${duplicatePressIds.join(', ')}. Please ensure all IDs are unique.`);
          }
          
          const pressContent = JSON.stringify(pressData, null, 2);
          filesToSave.push({
            path: PRESS_FILE_PATH,
            content: pressContent
          });
        }
        
        // Create a single commit with all files
        const commitMessage = 'Update content via admin';
        const commitData = await createSingleCommit(filesToSave, commitMessage);
        const commitSha = commitData.sha;
        
        // Dismiss the saving toast
        if (savingToast) {
          dismissToast(savingToast);
        }
        
        // Reload content to ensure we have the latest data and avoid stale state
        // This prevents issues where subsequent saves use stale SHAs
        try {
          await loadContent();
        } catch (reloadError) {
          console.warn('Failed to reload content after save:', reloadError);
          // Don't fail the save if reload fails, just log it
        }
        
        // Show commit success toast (auto-dismisses after 5 seconds)
        showToast(
          'Changes Committed',
          'Your changes have been successfully committed to GitHub.',
          'success',
          5000
        );
        
        // Show deployment monitoring toast (separate toast)
        const deploymentToast = showToast(
          'Deployment Status',
          'Waiting for deployment to start...',
          'info',
          0 // Don't auto-dismiss, we'll handle it in monitorDeployment
        );
        
        // Start monitoring GitHub Actions deployment status for this specific commit
        // Wait a bit longer to ensure the workflow run is created
        setTimeout(() => monitorDeployment(deploymentToast, commitSha), 3000); // Wait 3 seconds for workflow to start
        
        saveBtn.disabled = false;
        saveBtn.textContent = originalText;
        showStatus('Changes saved successfully! Monitoring deployment status...', 'success');
      } catch (error) {
        const saveBtn = document.getElementById('save-btn');
        saveBtn.disabled = false;
        saveBtn.textContent = 'Save All Changes';
        
        // Remove saving toast if it exists
        const savingToast = document.querySelector('.toast.info');
        if (savingToast) {
          savingToast.remove();
        }
        
        // Show error toast
        showToast(
          'Save Failed',
          error.message || 'An error occurred while saving changes.',
          'error',
          0 // Don't auto-close errors
        );
        
        showStatus('Error saving: ' + error.message, 'error');
        console.error(error);
      }
    });
    
    function validateAlbumId(albumIndex, input) {
      const newId = input.value.trim().toLowerCase();
      const errorDiv = document.getElementById(`id-error-${albumIndex}`);
      
      // Validate format: 3-4 lowercase letters followed by 3 digits (e.g., orth001, room001)
      const idPattern = /^[a-z]{3,4}[0-9]{3}$/;
      
      if (!newId) {
        errorDiv.textContent = 'ID is required (e.g., orth001, room001)';
        errorDiv.style.display = 'block';
        input.style.borderColor = '#dc3545';
        return false;
      }
      
      if (!idPattern.test(newId)) {
        errorDiv.textContent = 'ID must be in format: 3-4 lowercase letters followed by 3 digits (e.g., orth001, room001)';
        errorDiv.style.display = 'block';
        input.style.borderColor = '#dc3545';
        return false;
      }
      
      // Check for duplicates
      const duplicates = albumsData.albums.filter((album, index) => 
        album.id && album.id.toLowerCase() === newId && index !== albumIndex
      );
      
      if (duplicates.length > 0) {
        errorDiv.textContent = `ID ${newId} is already used by another album`;
        errorDiv.style.display = 'block';
        input.style.borderColor = '#dc3545';
        return false;
      }
      
      errorDiv.style.display = 'none';
      input.style.borderColor = '#ddd';
      albumsData.albums[albumIndex].id = newId;
      return true;
    }
    
    window.validateAlbumId = validateAlbumId;
    
    // Press Items Functions
    function renderPressItems() {
      const container = document.getElementById('press-list');
      if (!container) return;
      
      container.innerHTML = '';
      
      if (!pressData || !pressData.items || pressData.items.length === 0) {
        container.innerHTML = '<p style="color: #666; padding: 20px;">No press items yet. Click "Create New Press Item" to get started.</p>';
        return;
      }
      
      pressData.items.forEach((item, index) => {
        const itemDiv = document.createElement('div');
        itemDiv.className = 'item-item';
        itemDiv.setAttribute('data-index', index);
        
        const title = item.title || 'New Press Item (untitled)';
        
        itemDiv.innerHTML = `
          <div class="item-header">
            <h3>${escapeHtml(title)}</h3>
            <div class="item-controls">
              <button class="btn btn-small" onclick="movePressItem(${index}, 'up')" ${index === 0 ? 'disabled' : ''}>↑</button>
              <button class="btn btn-small" onclick="movePressItem(${index}, 'down')" ${index === pressData.items.length - 1 ? 'disabled' : ''}>↓</button>
              <button class="btn btn-small btn-danger" onclick="deletePressItem(${index})">Delete</button>
            </div>
          </div>
          <div class="meta">
            Publication: ${escapeHtml(item.publication || 'Not set')} | 
            Date: ${item.date || 'Not set'} |
            ${item.link ? `<a href="${escapeHtml(item.link)}" target="_blank" style="color: #0c5460; text-decoration: underline;">View Article</a>` : 'Link: Not set'}
          </div>
          
          <div class="form-row">
            <div class="form-group">
              <label>ID <span style="color: #dc3545;">*</span> <span style="color: #666; font-size: 12px;">(must be unique)</span></label>
              <input type="number" data-field="id" data-index="${index}" value="${item.id || ''}" min="1" required onchange="validatePressId(${index}, this)" style="${!item.id ? 'border-color: #dc3545;' : ''}">
              <div id="press-id-error-${index}" style="color: #dc3545; font-size: 12px; margin-top: 5px; display: none;"></div>
            </div>
            <div class="form-group">
              <label>Title <span style="color: #dc3545;">*</span></label>
              <input type="text" data-field="title" data-index="${index}" value="${escapeHtml(item.title || '')}" required style="${!item.title ? 'border-color: #dc3545;' : ''}">
            </div>
          </div>
          
          <div class="form-row">
            <div class="form-group">
              <label>Publication <span style="color: #dc3545;">*</span></label>
              <input type="text" data-field="publication" data-index="${index}" value="${escapeHtml(item.publication || '')}" required style="${!item.publication ? 'border-color: #dc3545;' : ''}">
            </div>
            <div class="form-group">
              <label>Author <span style="color: #666; font-size: 12px;">(optional)</span></label>
              <input type="text" data-field="author" data-index="${index}" value="${escapeHtml(item.author || '')}">
            </div>
          </div>
          
          <div class="form-row">
            <div class="form-group">
              <label>Date <span style="color: #dc3545;">*</span></label>
              <input type="date" data-field="date" data-index="${index}" value="${item.date || ''}" required style="${!item.date ? 'border-color: #dc3545;' : ''}">
            </div>
            <div class="form-group">
              <label>Category <span style="color: #666; font-size: 12px;">(optional, e.g., Review, Interview, Feature)</span></label>
              <input type="text" data-field="category" data-index="${index}" value="${escapeHtml(item.category || '')}">
            </div>
          </div>
          
          <div class="form-row">
            <div class="form-group">
              <label>Link <span style="color: #dc3545;">*</span> <span style="color: #666; font-size: 12px;">(URL to the article)</span></label>
              <input type="url" data-field="link" data-index="${index}" value="${escapeHtml(item.link || '')}" placeholder="https://..." required style="${!item.link ? 'border-color: #dc3545;' : ''}">
            </div>
            <div class="form-group">
              <label>Image <span style="color: #666; font-size: 12px;">(optional, URL or filename)</span></label>
              <input type="text" data-field="image" data-index="${index}" value="${escapeHtml(item.image || '')}" placeholder="URL or filename">
            </div>
          </div>
          
          <div class="form-group">
            <label>Excerpt <span style="color: #666; font-size: 12px;">(optional, short quote or description)</span></label>
            <textarea data-field="excerpt" data-index="${index}" rows="3" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: inherit;">${escapeHtml(item.excerpt || '')}</textarea>
          </div>
        `;
        
        container.appendChild(itemDiv);
      });
      
      // Attach input listeners
      container.querySelectorAll('input[data-field][data-index], textarea[data-field][data-index]').forEach(input => {
        input.addEventListener('change', updatePressItem);
      });
    }
    
    function createNewPressItem() {
      if (!pressData) {
        pressData = { items: [] };
      }
      
      // Find the highest ID and add 1
      const maxId = pressData.items.length > 0 
        ? Math.max(...pressData.items.map(item => item.id || 0))
        : 0;
      
      const newItem = {
        id: maxId + 1,
        title: '',
        publication: '',
        author: '',
        date: new Date().toISOString().split('T')[0],
        excerpt: '',
        link: '',
        image: '',
        category: ''
      };
      
      pressData.items.push(newItem);
      renderPressItems();
      showStatus('New press item created. Fill in the details and save.', 'info');
      
      // Scroll to the new item
      setTimeout(() => {
        const items = document.querySelectorAll('#press-list .item-item');
        if (items.length > 0) {
          items[items.length - 1].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
      }, 100);
    }
    
    function deletePressItem(index) {
      if (confirm('Are you sure you want to delete this press item?')) {
        pressData.items.splice(index, 1);
        renderPressItems();
        showStatus('Press item deleted. Remember to save changes.', 'info');
      }
    }
    
    function movePressItem(index, direction) {
      if (direction === 'up' && index > 0) {
        [pressData.items[index], pressData.items[index - 1]] = 
          [pressData.items[index - 1], pressData.items[index]];
        renderPressItems();
      } else if (direction === 'down' && index < pressData.items.length - 1) {
        [pressData.items[index], pressData.items[index + 1]] = 
          [pressData.items[index + 1], pressData.items[index]];
        renderPressItems();
      }
    }
    
    function updatePressItem(event) {
      const input = event.target;
      const field = input.dataset.field;
      const index = parseInt(input.dataset.index);
      const value = input.type === 'date' ? input.value : (input.type === 'number' ? (input.value ? parseInt(input.value) : undefined) : input.value);
      
      if (pressData.items[index]) {
        pressData.items[index][field] = value;
      }
    }
    
    function validatePressId(itemIndex, input) {
      const newId = parseInt(input.value);
      const errorDiv = document.getElementById(`press-id-error-${itemIndex}`);
      
      if (!newId || newId < 1) {
        errorDiv.textContent = 'ID must be a positive number';
        errorDiv.style.display = 'block';
        input.style.borderColor = '#dc3545';
        return false;
      }
      
      // Check for duplicates
      const duplicates = pressData.items.filter((item, index) => 
        item.id === newId && index !== itemIndex
      );
      
      if (duplicates.length > 0) {
        errorDiv.textContent = `ID ${newId} is already used by another press item`;
        errorDiv.style.display = 'block';
        input.style.borderColor = '#dc3545';
        return false;
      }
      
      errorDiv.style.display = 'none';
      input.style.borderColor = '#ddd';
      pressData.items[itemIndex].id = newId;
      return true;
    }
    
    window.createNewPressItem = createNewPressItem;
    window.deletePressItem = deletePressItem;
    window.movePressItem = movePressItem;
    window.validatePressId = validatePressId;
    
    function showStatus(message, type) {
      const statusDiv = document.getElementById('status');
      statusDiv.textContent = message;
      statusDiv.className = `status ${type}`;
      statusDiv.classList.remove('hidden');
      
      if (type === 'success') {
        setTimeout(() => {
          statusDiv.classList.add('hidden');
        }, 3000);
      }
    }
    
    function showToast(title, message, type = 'info', duration = 5000) {
      const container = document.getElementById('toast-container');
      if (!container) return;
      
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      
      const icons = {
        success: '✓',
        error: '✕',
        info: 'ℹ',
        warning: '⚠'
      };
      
      toast.innerHTML = `
        <span class="toast-icon">${icons[type] || icons.info}</span>
        <div class="toast-content">
          <div class="toast-title">${escapeHtml(title)}</div>
          <div class="toast-message">${escapeHtml(message)}</div>
        </div>
        <button class="toast-close" onclick="dismissToast(this.parentElement)">×</button>
      `;
      
      container.appendChild(toast);
      
      // Auto-remove after duration (unless it's an error, which stays until manually closed)
      if (type !== 'error' && duration > 0) {
        setTimeout(() => {
          dismissToast(toast);
        }, duration);
      }
      
      return toast;
    }
    
    function dismissToast(toast) {
      if (toast && toast.parentElement) {
        toast.classList.add('dismissing');
        setTimeout(() => {
          if (toast.parentElement) {
            toast.remove();
          }
        }, 300);
      }
    }
    
    window.dismissToast = dismissToast;
    
    async function checkGitHubActionsStatus(commitSha = null) {
      try {
        // If commit SHA is provided, find the workflow run for that specific commit
        // Otherwise, get the latest workflow run
        let url = `${PROXY_URL}/repos/${REPO_OWNER}/${REPO_NAME}/actions/runs?per_page=10`;
        if (commitSha) {
          url += `&head_sha=${commitSha}`;
        }
        
        const response = await fetch(url, {
          headers: {
            'Authorization': `token ${token}`,
            'Accept': 'application/vnd.github.v3+json'
          }
        });
        
        if (!response.ok) {
          return null;
        }
        
        const data = await response.json();
        if (data.workflow_runs && data.workflow_runs.length > 0) {
          // If we're looking for a specific commit, find the matching run
          // Otherwise, get the latest run
          let run = null;
          if (commitSha) {
            run = data.workflow_runs.find(r => r.head_sha === commitSha);
            // If not found, fall back to latest run (might be queued but not yet associated)
            if (!run) {
              run = data.workflow_runs[0];
            }
          } else {
            run = data.workflow_runs[0];
          }
          
          if (run) {
            return {
              status: run.status, // queued, in_progress, completed
              conclusion: run.conclusion, // success, failure, cancelled, etc.
              html_url: run.html_url,
              created_at: run.created_at,
              updated_at: run.updated_at,
              head_sha: run.head_sha
            };
          }
        }
        return null;
      } catch (error) {
        console.error('Error checking GitHub Actions status:', error);
        return null;
      }
    }
    
    async function monitorDeployment(toastElement, commitSha = null) {
      const maxChecks = 30; // Check for up to 5 minutes (30 checks * 10 seconds)
      let checkCount = 0;
      
      const checkInterval = setInterval(async () => {
        checkCount++;
        const status = await checkGitHubActionsStatus(commitSha);
        
        // Ensure deployment status div exists
        let statusDivEl = toastElement.querySelector('.deployment-status');
        if (!statusDivEl) {
          statusDivEl = document.createElement('div');
          statusDivEl.className = 'deployment-status active';
          toastElement.querySelector('.toast-content').appendChild(statusDivEl);
        }
        
        if (!status) {
          // Can't get status yet - workflow might not have started
          if (checkCount < 5) {
            // Keep checking for the first few attempts
            statusDivEl.innerHTML = `
              <span class="deployment-spinner"></span>
              <span>Waiting for deployment to start... (checking ${checkCount}/${maxChecks})</span>
            `;
            return;
          } else {
            // After 5 checks, stop checking
            clearInterval(checkInterval);
            toastElement.className = 'toast warning';
            toastElement.querySelector('.toast-icon').textContent = '⚠';
            toastElement.querySelector('.toast-title').textContent = 'Deployment Status Unknown';
            toastElement.querySelector('.toast-message').textContent = 'Could not determine deployment status. Check GitHub Actions manually.';
            statusDivEl.innerHTML = `
              <a href="https://github.com/${REPO_OWNER}/${REPO_NAME}/actions" target="_blank" class="deployment-status-link">View workflows →</a>
            `;
            setTimeout(() => dismissToast(toastElement), 10000);
            return;
          }
        }
        
        // Check if this is the workflow run for our commit (if commitSha was provided)
        if (commitSha && status.head_sha && status.head_sha !== commitSha) {
          // This is not our workflow run yet, keep checking
          if (checkCount < 10) {
            statusDivEl.innerHTML = `
              <span class="deployment-spinner"></span>
              <span>Waiting for deployment workflow to start... (checking ${checkCount}/${maxChecks})</span>
            `;
            return;
          }
        }
        
        if (statusDivEl) {
          if (status.status === 'completed') {
            clearInterval(checkInterval);
            
            if (status.conclusion === 'success') {
              // Update toast to show success
              toastElement.className = 'toast success';
              toastElement.querySelector('.toast-icon').textContent = '✓';
              toastElement.querySelector('.toast-icon').style.color = '#28a745';
              toastElement.querySelector('.toast-title').textContent = 'Deployment Completed';
              toastElement.querySelector('.toast-message').textContent = 'Your changes are now live on the website!';
              
              statusDivEl.innerHTML = `
                <a href="${status.html_url}" target="_blank" class="deployment-status-link">View workflow →</a>
              `;
              
              // Auto-dismiss after 5 seconds
              setTimeout(() => {
                dismissToast(toastElement);
              }, 5000);
            } else if (status.conclusion === 'failure') {
              // Update toast to show error
              toastElement.className = 'toast error';
              toastElement.querySelector('.toast-icon').textContent = '✕';
              toastElement.querySelector('.toast-icon').style.color = '#dc3545';
              toastElement.querySelector('.toast-title').textContent = 'Deployment Failed';
              toastElement.querySelector('.toast-message').textContent = 'Deployment failed. Check workflow for details.';
              
              statusDivEl.innerHTML = `
                <a href="${status.html_url}" target="_blank" class="deployment-status-link">View workflow →</a>
              `;
              
              // Auto-dismiss after 5 seconds
              setTimeout(() => {
                dismissToast(toastElement);
              }, 5000);
            } else {
              // Other conclusion (cancelled, etc.)
              toastElement.className = 'toast warning';
              toastElement.querySelector('.toast-icon').textContent = '⚠';
              toastElement.querySelector('.toast-icon').style.color = '#ffc107';
              toastElement.querySelector('.toast-title').textContent = 'Deployment Status';
              toastElement.querySelector('.toast-message').textContent = `Deployment ${status.conclusion || 'completed'}.`;
              
              statusDivEl.innerHTML = `
                <a href="${status.html_url}" target="_blank" class="deployment-status-link">View workflow →</a>
              `;
              
              // Auto-dismiss after 5 seconds
              setTimeout(() => {
                dismissToast(toastElement);
              }, 5000);
            }
          } else if (status.status === 'in_progress' || status.status === 'queued') {
            statusDivEl.innerHTML = `
              <span class="deployment-spinner"></span>
              <span>Deployment in progress... (checking ${checkCount}/${maxChecks})</span>
              <a href="${status.html_url}" target="_blank" class="deployment-status-link">View workflow →</a>
            `;
          }
        }
        
        // Stop checking after max attempts
        if (checkCount >= maxChecks) {
          clearInterval(checkInterval);
          if (statusDivEl) {
            toastElement.querySelector('.toast-title').textContent = 'Deployment Status';
            toastElement.querySelector('.toast-message').textContent = 'Still deploying... Check back in a few minutes.';
            statusDivEl.innerHTML = `
              <a href="${status.html_url || '#'}" target="_blank" class="deployment-status-link">View workflow →</a>
            `;
            
            // Auto-dismiss after 5 seconds
            setTimeout(() => {
              dismissToast(toastElement);
            }, 5000);
          }
        }
      }, 10000); // Check every 10 seconds
    }
    
    function escapeHtml(text) {
      if (text === null || text === undefined) return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
  </script>
</body>
</html>
